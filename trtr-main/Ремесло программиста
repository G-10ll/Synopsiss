1 глава
Держим оборону
1. На пути к хорошему коду
Есть огромная разница между кодом, который на первый взгляд работа%
ет, правильным кодом и хорошим кодом. М. Э. Джексон (M. A. Jackson)
писал: «Всякий мудрый программист должен понимать, что есть раз%
ница между тем, чтобы заставить программу работать, и тем, чтобы за%
ставить ее делать это правильно». (Jackson 75) И вот в чем эта разница:
• Легко написать код, который почти всегда работает. Вводишь
в программу обычные данные и получаешь обычные результаты.
Но стоит подать на вход нечто необычное, и все может рухнуть.
• Правильный код не рухнет. Для любого набора входных данных ре%
зультат будет корректен. Однако обычно количество всевозможных
комбинаций входных данных оказывается невероятно большим,
и все их трудно протестировать.
• Однако не всякий правильный код оказывается хорошим – напри%
мер, его логику трудно проследить, код непонятен, его практически
невозможно сопровождать.
2. Готовьтесь к худшему
Предположения служат причиной появления кода с ошибками. Очень
легко предположить следующее:
• Функцию никогда не станут вызывать таким способом. Ей всегда
будут передаваться только допустимые параметры.
• Этот фрагмент кода всегда будет работать, он никогда не сгенериру%
ет ошибку.
• Никто не станет пытаться обратиться к этой переменной, если
я напишу в документации, что она предназначена только для
внутреннего употребления.
3. Что такое защитное программирование
Как следует из названия, защитное программирование – это тщатель%
ное, осторожное программирование. Чтобы построить надежную про%
грамму, мы должны спроектировать каждую компоненту системы так,
чтобы она была как можно лучше защищена. Мы расправимся с непи%
саными допущениями, сделав для них явные проверки в коде. Таким
способом мы попытаемся предотвратить или хотя бы обнаружить такое
обращение к нашему коду, которое вызывает некорректное поведение.
Защитное программирование позволяет обнаружить мелкие проблемы
на ранней стадии, не дожидаясь момента, когда они приведут к серьез%
ным катастрофам. Сплошь и рядом можно столкнуться с тем, как
«профессиональные» разработчики спешат написать код, не дав себе
труда задуматься.
4. Этот страшный, ужасный мир
Защитное программирование повышает безопасность программ, пред%
охраняя от такого рода умышленного злоупотребления. Взломщики и
создатели вирусов не упускают случая воспользоваться неаккуратно
написанным кодом, чтобы получить контроль над приложением и реа%
лизовать свои зловредные планы. Это серьезная угроза в современном
мире программных разработок, которая приводит к огромному ущер%
бу, наносимому продуктивности, финансам и конфиденциальности.
5. Технологии защитного программирования
Защитное программирование предполагает соблюдение ряда разум%
ных правил. Обычно, когда заходит речь о защитном программирова%
нии, людям приходит в голову использовать операторы контроля,
и это правильно. Мы поговорим о них позже. Но существует также мас%
са простых приемов программирования, которые неизмеримо повысят
надежность вашего кода.
6. Выберите хороший стиль кодирования 
и пользуйтесь крепкой архитектурой
Значительной части ошибок можно избежать, придерживаясь доброт%
ного стиля кодирования. Это правило согласуется с остальными глава%
ми данной части. Такие простые вещи, как выбор осмысленных имен
переменных и разумная расстановка скобок, делают код понятнее
и уменьшают шансы пропустить ошибку.
7. Пишите код без спешки
Сплошь и рядом программы пишут сломя голову. Программист быстренько ляпает функцию, пропускает ее через компилятор для проверки синтаксиса, запускает, чтобы убедиться в ее работоспособности,
и переходит к очередной задаче. Такой подход чреват опасными по%
следствиями.
8. Не верьте никому
• Обычный пользователь случайно введет в программу неверные
данные или воспользуется ею некорректно.
• Злоумышленник сознательно попытается заставить программу ве%
сти себя некорректно.
• Клиентский код вызовет вашу функцию, неправильно передав ей
параметры или задав им недопустимые значения.
• Операционная среда не сможет предоставить программе необходи%
мый сервер.
• Внешние библиотеки окажутся некорректными и не выполнят те
контракты по интерфейсам, на которые вы полагались.
9. Стремитесь к ясности, а не к краткости
Когда встает выбор между кратким (но непонятным) и ясным (но скуч%
ным) кодом, делайте его в пользу того кода, смысл которого понятен,
даже если он менее элегантен. Например, сложные арифметические
выражения разбивайте на последовательность отдельных операторов,
логика которых понятнее.
10. Не позволяйте никому лезть туда, где ему нечего делать
• В объектно%ориентированных языках доступ к внутренним данным
класса запрещается путем объявления его закрытым. В C++ можно
воспользоваться идиомой Чеширского кота (или pimpl) – стандарт%
ным приемом, употребляемым для выведения внутренней структу%
ры класса из его открытого файла заголовка. (Meyers 97) 
• В процедурных языках также можно воспользоваться идеями объ%
ектно%ориентированной упаковки, заключив закрытые данные внут%
ри непрозрачных типов и обеспечив корректные операции над ними. 
• Дайте всем переменным минимально необходимую область видимо%
сти; не делайте их глобальными, если в этом нет необходимости. Ес%
ли их можно сделать локальными для функции, не объявляйте их
на уровне файла. Если их можно сделать локальными для цикла, не
объявляйте их на уровне функции.
11. Включайте вывод всех предупреждений при компиляции
Если ваш код изобилует опасными конструкциями, такие предупреж%
дения могут занять многие страницы. К сожалению, по этой причине
очень часто отключают вывод предупреждений компилятором или
просто не обращают на них внимания. Так поступать не следует.
Всегда включайте вывод предупреждений компилятором, и если ваш
код генерирует предупреждения, немедленно исправьте его, чтобы та%
ких сообщений больше не было. Нельзя успокаиваться, пока компиля%
ция не станет проходить гладко при включенном выводе предупрежде%
ний. Они существуют не зря. Даже когда вам кажется, что какое%то
предупреждение несущественно, добейтесь его исчезновения, потому
что в один прекрасный день из%за него вы не заметите того предупреж%
дения, которое окажется действительно важным.
12. Пользуйтесь средствами статического анализа
Предупреждения компилятора представляют собой результат частич%
ного статического анализа кода – контроля кода, проводимого перед
запуском программы.
13. Применяйте безопасные структуры данных
Вероятно, самым распространенным видом уязвимостей в программах
является переполнение буфера. Оно возникает из%за небрежного при%
менения структур данных фиксированного размера. Если ваш код за%
писывает данные в буфер, не проверив предварительно его размер, то
возникает опасность записи за концом буфера.
14. Проверяйте все возвращаемые значения
Если функция возвращает значение, то делает это не зря. Проверяйте
возвращаемое значение. Если это код ошибки, нужно ее обработать.
Не допускайте появления в программе незамеченных ошибок; в итоге
поведение программы может стать непредсказуемым.
15. Аккуратно обращайтесь с памятью 
(и другими ценными ресурсами)
Будьте скрупулезны и освобождайте все ресурсы, которые захватывае%
те во время выполнения. Чаще всего имеется в виду оперативная па%
мять, но это не единственный ресурс. К другим видам ценных ресурсов,
которые нужно беречь, относятся файлы и блокировки потоков. Рас%
поряжайтесь своим добром экономно.
16. Инициализируйте все переменные там, где вы их объявили
Это проблема ясности. Смысл каждой переменной становится ясен, ес%
ли вы инициализируете ее. Опасно полагаться на эмпирические пра%
вила типа: «Раз я ее не инициализировал, значит, ее начальное значе#
ние мне неважно». Код со временем развивается. Отсутствие началь%
ного значения на каком%то этапе может превратиться в проблему.
17. Объявляйте переменные как можно позже
Благодаря этому переменная будет располагаться ближе к месту сво%
его использования и не станет мешаться в других частях кода. Кроме
того, понятнее станет код, в котором участвует эта переменная. Вам не
придется рыскать, выясняя тип и значение переменной: расположен%
ное рядом объявление сделает их очевидными.
18. Пользуйтесь стандартными средствами языка
C и C++ в этом отношении представляют собой кошмар. Их специфи%
кации существуют во многих вариантах, а поведение в наименее ясных
ситуациях не определено и оставлено на усмотрение конкретных реа%
лизаций. На сегодняшний день существует множество компиляторов,
обладающих тонкими различиями. В целом они совместимы между со%
бой, но оставляют вам достаточно возможностей свернуть себе шею.
19. Пользуйтесь хорошими средствами регистрации 
диагностических сообщений
Когда пишут новый код, то часто включают в него много операторов
вывода диагностики, чтобы разобраться в происходящем в программе.
Следует ли удалить их в конце работы? Сохранив их, вы облегчите
себе жизнь в будущем, если придется вернуться к этому коду, особен%
но если можно управлять выводом диагностики.
20. Выполняйте приведение типов с осторожностью
Большинство языков позволяет приводить (преобразовывать) данные
из одного типа в другой. Эта операция не всегда проходит успешно. Ес%
ли вы попытаетесь преобразовать 64%разрядное целое в меньший, 8%раз%
рядный тип, то что произойдет с 56 оставшимися битами? Среда вы%
полнения может неожиданно сгенерировать исключительную ситуа%
цию, а может исказить ваши данные, ничего при этом не сообщив.
Программисты часто не задумываются над такого рода вещами, а по%
тому их программы ведут себя неожиданным образом.
21. Подробности
Определяйте поведение по умолчанию
В большинстве языков есть оператор switch (переключатель), позво%
ляющий любую неожиданность обработать в группе default (по
умолчанию). Если попадание в default является ошибкой, явно от%
разите это в коде. Если ошибки нет, также отразите это в коде, и то%
гда сопровождающему код программисту станет все ясно.
Аналогично, если вы пишете оператор if без предложения else, за%
думайтесь, не следует ли обрабатывать логический случай по умол%
чанию.
Пользуйтесь идиомами языка
Следуя этому простому совету, вы гарантируете, что ваш код будет
понятен читающим его. Они реже будут ошибаться.
Проверяйте числовые результаты
Даже самые простые вычисления могут приводить к переполнению
или потере точности. Будьте настороже. Спецификации языков и ба%
зовые библиотеки предоставляют механизмы для определения до%
пустимых значений стандартных типов данных – воспользуйтесь
ими. Вы должны знать, какие числовые типы существуют и для ка%
ких целей их лучше применять.
Проверяйте допустимость каждого вычисления. Например, следи%
те за тем, чтобы ваши величины не приводили к делению на ноль.
Соблюдайте защищенность констант
Особенно это облегчает жизнь при программировании на C/C++. Ста%
райтесь объявлять как const все, что только можно. Этим достигают%
ся две цели: квалификаторы const способствуют документированию
кода и позволяют компилятору обнаруживать глупые ошибки. Он не
позволит вам изменить данные, модификация которых запрещена.
22. Ограничения
. Есть несколько вариантов реакции программы:
• Сделать вид, что ничего не случилось, и надеяться на лучшее.
• Оштрафовать на месте и разрешить дальнейшее движение (напри%
мер, напечатать диагностическое предупреждение или записать его
в журнал).
• Сразу арестовать; запретить двигаться дальше (например, прервать
выполнение программы контролируемым или неконтролируемым
образом).
Существует несколько разных сценариев использования ограничений:
Входные условия
Эти условия должны быть выполнены до входа в раздел кода. Если
входное условие не выполнено, это означает, что в коде клиента
есть ошибка.
Выходные условия
Эти условия должны быть выполнены после выхода из блока кода.
Если выходное условие не выполнено, это означает, что в коде по%
ставщика есть ошибка.
Инварианты
Эти условия должны быть выполнены при достижении в ходе вы%
полнения программы определенной точки, например между прохо%
дами цикла, при вызове методов и т. п. Невыполнение инварианта
означает, что в логике программы есть ошибка.
Операторы контроля
Это любое другое утверждение относительно состояния программы
в данный момент.
23. Какие ограничения налагать
Есть несколько проблем, которые можно решать с помощью ограниче%
ний. Например, можно делать следующее:
• Проверять, чтобы все обращения к массивам не выходили за их гра%
ницы.
• Контролировать неравенство нулю указателей перед их разымено%
ванием.
• Проверять допустимость параметров функций.
• Контролировать результаты функций, прежде чем их возвращать.
• Проверять состояние объекта перед операциями с ним.
• Защищать те участки кода, где должны быть комментарии. Они не
должны получать управление.
24. Снятие ограничений
Такого рода проверка ограничений обычно требуется только на этапах
разработки и отладки программы. После того как мы воспользовались
ограничениями, чтобы убедить себя (возможно, ошибочно) в правиль%
ности логики программы, следовало бы убрать их, чтобы готовая про%
грамма не делала лишней работы.
25. Резюме
Необходимо писать не просто корректный, но хороший код. Для этого
нужно документировать все сделанные предположения. В результате
код станет легче сопровождать и в нем окажется меньше места для
ошибок. Защитное программирование ориентировано на то, чтобы быть
готовым к худшему, что может случиться. Данная технология препят%
ствует превращению случайных огрехов в трудноуловимые ошибки.
2 глава
Тонкий расчет
1. Да в чем проблема?
Расположение и представление кода оказываются предметом разно%
гласий в большинстве современных языков программирования. Про%
извольное форматирование, позволяющее выразить свою художест%
венную индивидуальность, вошло в моду в начале 1960%х годов с появ%
лением Алгола: существовавшие к тому времени версии Fortran до%
пускали меньше свободы в формате. В последующем лишь очень
немногие языки отошли от такого подхода к свободе форматирования.
2. Знайте своих клиентов
Чтобы написать эффективный исходный код, необходимо понимать,
кто его будет читать. Если придется кого%то поставить в трудное поло%
жение, выясните, перед кем потом извиняться. В действительности,
есть три круга адресатов вашего кода:
Вы сами
У меня такой плохой почерк, что иногда мне самому трудно его ра%
зобрать. Это практически невозможно, если я не ставлю себе задачу
писать разборчиво. То же самое происходит и с кодом. Созданное ва%
ми должно быть понятно не только сразу после написания, но и по
прошествии лет. Кто мог подумать, что придется вернуться к (отно%
сительно) архаичному коду на COBOL, чтобы исправить в нем
ошибки, связанные с Y2K?
Компилятор
Компилятору все равно, как выглядит ваш код, – лишь бы в нем не
было синтаксических ошибок. Ему абсолютно безразлично, какую
задачу этот код решает. Можно подробно описать в комментариях,
что должна делать функция, но компилятор никогда не сообщит вам,
действительно ли она выполняет то, что сказано в комментариях.
Если код корректен, среда разработки будет вполне удовлетворена.
Прочие лица 
Это самая важная аудитория, интересы которой часто меньше всего
учитываются. 
Вам кажется, что хотя вы работаете в составе команды, никто нико%
гда не станет смотреть ваш код. Это ошибочное мнение.
Вы пишете какой%то код для себя дома. Стоит ли заботиться о его кра%
соте? Если «да», то в чем польза? В выработке качеств, которые дела%
ют вас профессионалом. У вас появляется прекрасная возможность
продемонстрировать настоящую дисциплину в проекте, когда никто
не оказывает на вас давления. Это возможность выработать хорошие
манеры. Если вы не справитесь с задачей в таких условиях, то неуди%
вительно, что у вас не хватит дисциплины в реальных проектах. 
3. Что такое хорошее представление?
Расположение кода должно передавать его смысл, а не скрывать.
Я предлагаю следующие критерии качества стиля представления кода.
Единообразие
Принципы отступов в коде должны быть одинаковы во всех частях
проекта. Не меняйте стиль в середине пути. Это не только выглядит
непрофессионально, но и может ввести в заблуждение, создавая
впечатление отсутствия связи между файлами с исходным кодом.
Отдельные правила представления должны быть внутренне непроти%
воречивыми. Расположение фигурных и квадратных скобок и т. п.
в различных ситуациях должно соответствовать единым правилам.
Количество пробелов в отступах должно быть всегда одинаковым.
Керниган и Ричи, основоположники C, подчеркивают важность
правильных отступов и затем говорят: «Положение скобок менее
важно, хотя люди склонны проявлять фанатизм в таких вопросах.
Мы выбрали один из нескольких популярных стилей. Выберите тот
стиль, который вам больше подходит, и точно ему следуйте». (Ker%
nighan Ritchie 88)
Стандартность
Разумно принять какой%нибудь из господствующих ныне стилей,
а не изобретать собственные правила отступа. Так будет проще для
тех, кто станет читать ваш код. И меньше шансов, что ваш стиль
вызовет у них отвращение.
Краткость
Можете ли вы кратко описать свою стратегию отступов? Подумайте
над этим. Если вы делаете нечто, пока не произойдет то#то и то#
то, а тогда вы будете делать это, если выполняется X; в противном
случае вы станете делать нечто другое в зависимости от…
Кому%то может потребоваться дополнить написанный вами код, и де%
лать это ему следует, придерживаясь того же стиля. Если его трудно
ухватить, можно ли считать такой стиль представления удачным?
4. Размещение скобок
Для иллюстрации влияния, которое представление оказывает на ис%
ходный код, и компромиссов, на которые приходится идти при выборе
стиля, разберем конкретный случай, связанный с важной проблемой
расположения кода C. Рассматривая варианты, возникающие в этой
одной простой области, мы продемонстрируем важность представле%
ния и степень его влияния на код.
5. Скобки в стиле K&R
Стиль K&R относится к старейшим, будучи предложенным основопо%
ложниками языка C, Керниганом и Ричи, в книге «Язык программи%
рования C» (Kernighan Ritchie 88). По этой причине его часто считают
исходным и лучшим. На него повлияла необходимость отобразить как
можно больше информации на маленьком экране. Пожалуй, это пре%
валирующий стиль для кода Java.
6. Расширенный стиль скобок
Более свободное расположение кода достигается в расширенном (ex#
dented) стиле, называемом также стилем Олмана. Лично мне он нра%
вится больше прочих.
7. Стиль Уайтсмита (с отступами)
Стиль с отступами менее распространен, хотя и встречается. Фигур%
ные скобки при этом имеют тот же отступ, что и код. Он получил на%
звание стиля Уайтсмита, поскольку применялся в примерах для
Whitesmiths C – раннего компилятора с языка С.
8. Другие стили скобок
Существуют и другие стили. Например, стиль GNU занимает промежу%
точное положение между расширенным стилем и стилем с отступами:
скобки располагаются посередине каждого уровня отступа. Есть и гиб%
ридные стили: стиль кода ядра Linux наполовину представляет K&R,
наполовину – стиль Олмана. Большинство программирующих на C#
тоже комбинирует стили расположения.
9. Единственно верный стиль
Поняв, что такое правильный стиль кодирования, на что он влияет
и почему необходим, нужно выбрать для себя что%то подходящее. Вот
тут и начинается столкновение. Последовательности одного религиоз%
ного течения в представлении ведут борьбу с проповедниками другого,
порождая гражданские войны между программистами. Но настоящий
мастер не ввязывается в эти мелкие дрязги, предпочитая взвешенный
подход.
10. Внутрифирменные стили 
(и когда их придерживаться)
Важность и полезность внутрифирменных стилей обусловлена рядом
причин. Когда все танцуют под одну дудку, исходный код оказывается
полностью единообразным и однородным. Что в этом хорошего? Улуч%
шается качество кода и растет надежность разработки программного
обеспечения. И вот почему:
• Любой код, выходящий за пределы организации, имеет аккуратное
представление и согласованность, создавая впечатление хорошей
продуманности. Наличие в одном проекте разнородных стилей соз%
дает впечатление неряшливости и непрофессионализма.
• Компания может быть уверена в том, что программы пишутся со%
гласно единому стандарту, включающему в себя определенные
идиомы и методологии. Это не гарантирует получение хорошего ко%
да, но дает некоторую защиту от появления плохого кода.
• Компенсируются недостатки инструментария: по разному настро%
енные IDE будут вступать в конфликт между собой, разрывая код
на части и досаждая форматированием. Стандарт создает ровную
почву (и общего врага для всех программистов).
• Привлекательна возможность сразу оценить состояние кода, напи%
санного коллегами, и быстро сделать необходимые изменения при
сопровождении. Меньше времени тратится на чтение, а значит, бе%
регутся финансовые ресурсы компании.
• Поскольку программисты перестанут непрерывно заново формати%
ровать код в соответствии со своими эстетическими пристрастия%
ми, система управления версиями станет намного эффективнее. Ес%
ли один программист будет переформатировать код второго, чтобы
привести его к «своему» стилю, это отразится на работе утилит,
сравнивающих версии. Многие из них действуют довольно грубо
и покажут массу несущественных различий в расстановке пробель%
ных символов и скобок.
11. Установка стандарта
Сложность задачи зависит от особенностей членов вашего коллектива:
• Сколько всего программистов
• Как каждый в отдельности пишет код
• Насколько схожи между собой их стили программирования
• Заинтересованы ли они в наличии стандарта
• Готовы ли они к тому, чтобы изменить свой стиль
12. Религиозные войны?
Вести религиозные войны по поводу форматирования кода – пустая
трата времени; есть гораздо более важные проблемы, заслуживающие
вашего внимания. Но будьте осторожны: формат кода – не единствен%
ное больное место у программистов. Помимо него существуют выбор
редактора, компилятора, методологии, Настоящего языка1 и т. д.
13. Резюме
Представление – одна из главных характеристик, отличающих хоро%
ший код от плохого. Программист может многое узнать по внешнему
виду кода, поэтому стоит позаботиться о его надлежащем форматиро%
вании. Важно уметь толково расположить код в соответствии с прави%
лами существующего в фирме стандарта кодирования, обеспечив его
максимальную понятность.
3 глава
Что в имени тебе моем?
1. Зачем нужны хорошие имена?
Нужно тщательно выбирать имена для своих объектов. Ведь исходный
код должен быть понятен. Имя создает путь к пониманию, контролю
и овладению. Если правильно выбрать имя, по нему можно понять на#
значение объекта. 
2. Каким объектам мы даем имена?
Задумаемся как программисты над тем, каким объектам мы даем име%
на и какие имена мы им даем. Сначала о том, какие конструкции ча%
ще всего получают от нас имена, когда мы пишем код:
• Переменные
• Функции
• Типы (классы, перечисления, структуры, определения типов)
• Имена пространств C++ и пакетов Java
• Макросы
• Файлы с исходным текстом
3. Игра в названия
Какое назначить имя? Техника создания любого имени зависит от
стандарта кодирования, которого вы придерживаетесь. Однако хотя
стандарт и определяет некоторые правила составления имен, он не бы%
вает настолько конкретным, чтобы определить правильное имя любо%
го элемента, входящего в программу. 
4. Технические подробности
В следующих разделах обсуждается, как выбирать имена в каждой из
перечисленных категорий объектов. Даже если у вас многолетний опыт
программирования, обзор существующих принципов формирования
имен может оказаться полезен и для вас.
5. Роза пахнет розой
Значение имени больше, чем может показаться на первый взгляд, и су%
ществует масса соображений при выборе имени для программного объ%
екта. Какими главными принципами следует руководствоваться? 
Чтобы выбрать хорошее имя, нужно:
• Соблюдать единообразие
• Связывать имя с содержимым
• Извлекать из имен практическую пользу
6. Резюме
Наши предки знали в те времена то, что хорошие программисты знают
сейчас: очень важно правильно выбрать имя. Хорошие имена не про%
сто удовлетворяют эстетическую потребность – они передают инфор%
мацию о структуре кода. Они служат важным средством, позволяю%
щим облегчить понимание и сопровождение кода. 
4 глава
Литературоведение 
1. Самодокументируемый код
Гордиться тут, собственно, нечем. Сложная и имеющая практическую
ценность программа требует большого мастерства. Практика показы%
вает, что читать компьютерные программы гораздо сложнее, чем пи%
сать их. Всякий, кто знаком с Perl, это подтвердит: данный язык пред%
ставлялся как предельный случай «напиши и забудь». И вправду, ста%
рый код Perl может казаться совершенно непостижимым. Однако не%
понятный код можно написать на любом языке, и особых стараний
для этого не требуется.
2. Техника написания самодокументируемого кода
Обычно считается, что самодокументируемый код должен содержать
в себе обилие комментариев. Хорошие комментарии, несомненно, нуж%
ны, но ими дело не ограничивается. На самом деле нужно стремиться
избегать комментариев путем написания такого кода, в котором в них
нет необходимости.
3. Практические методологии 
самодокументирования
В завершение этой главы мы сравним два конкретных метода докумен%
тирования кода. Помните, что эти методы менее предпочтительны, чем
те, которые мы уже рассмотрели. Как сказано у Кернигана и Плоэра,
«нужно не документировать плохой код, а переписать его заново».
4. Резюме 
Мы пишем код для того, чтобы передать информацию. Код без доку%
ментации опасен и малоинформативен. Его трудно сопровождать.
Плохая документация также создает проблемы: она либо вводит чита%
теля в заблуждение, либо делает программу ненадежной и требующей
дополнительных разъяснений.
5 глава
1. Что есть комментарий в коде?
Синтаксически комментарий представляет собой блок исходного тек%
ста, который игнорируется компилятором. Поместить в него можно
что угодно – хоть имена своих внуков, хоть цвет любимой рубашки;
компилятор и глазом не моргнет, встретив такое в файле.
2. Как выглядят комментарии?
Комментарии C помещаются в блоках между комбинациями /* и */
и могут занимать произвольное количество строк. В C++, C99, C#
и Java есть, кроме того, однострочные комментарии, следующие за //.
В других языках есть аналогичные средства комментирования блока#
ми и в строке, но синтаксис иной. 
3. Сколько комментариев требуется
Тех, кто изучает программирование, заставляют писать комментарии,
и в большом количестве. Но слишком обширные комментарии могут
быть недостатком – важные фрагменты кода оказываются затерянны%
ми среди потока слов. Когда вам приходится продираться через про%
странные комментарии, вместо того чтобы читать сам код, качество
последнего снижается. 
4. Что помещать в комментарии? 
Лучше совсем без комментариев, чем плохие комментарии – они дез%
информируют читателя и вводят его в заблуждение. Что же следует
помещать в комментарии? Вот несколько основных советов, как повы%
сить качество комментариев.
5. На практике
Проиллюстрируем принципы комментирования следующим приме%
ром. Рассмотрим фрагмент кода C++. Даже если не критиковать идио%
матическую сторону, код не вполне понятен.
6. Замечание об эстетичности
Несомненно, вам приходилось сталкиваться с горячими обсуждения%
ми того, как нужно форматировать комментарии. Я не намерен на%
ставлять вас на путь истинный в этом вопросе (его просто не существу%
ет), но есть ряд важных аспектов, которые нужно учитывать. Отнеси%
тесь к ним как к общим принципам, сообразуясь с вашими личными
вкусами, а не как к безусловным требованиям. 
7. Работа с комментариями 
Комментариями удобно пользоваться при написании кода. Но не зло%
употребляйте ими.
8. Резюме
Мы пишем много комментариев. Это вызвано тем, что мы пишем мно%
го кода. Важно научиться писать правильные комментарии, иначе
наш код может потонуть под грузом бестолковых или устаревших
комментариев. 
Не нужно переоценивать значение комментариев; благодаря хорошим
комментариям плохой код лучше не станет. Целью должно быть напи%
сание самодокументируемого кода, для которого не требуются ника%
кие комментарии.
6 глава
Людям свойственно ошибаться
1. Откуда что берется
Ошибки были и будут. Неприятные результаты могут быть следствием
почти любой операции. Это не то же самое, что дефект программы, по%
скольку вы заранее знаете, что может произойти ошибка. Например,
вам нужно открыть файл базы данных, а он оказывается удален, или
диск переполнен, и операция записи становится невозможной, или не%
доступен требуемый веб%сервис. 
Ошибки пользователя
Глупый юзер варварски обращается с вашей любимой программой.
Возможно, он ввел неверные данные или попытался выполнить со%
вершенно бессмысленную операцию. Хорошая программа укажет
на ошибку и поможет пользователю исправить ее. Она не станет из%
деваться над ним или жаловаться непонятно на что. 
Ошибка программиста
Пользователь действовал правильно, но код некорректен. Где%то
есть дефект, недосмотр программиста, с которым пользователь ни%
чего не может сделать (кроме как постараться избегать в будущем).
В идеале таких ошибок быть не должно. 
Здесь возникает замкнутый круг: необрабатываемые аварийные си%
туации приводят к ошибкам в программе. А эти ошибки могут при%
водить к возникновению аварийных ситуаций в других местах ко%
да. Поэтому мы считаем защитное программирование важной тех%
нологией.
Исключительные обстоятельства
Пользователь действовал правильно, и программист ничего не напу%
тал. Вмешалась неверная судьба, и мы столкнулись с чем%то, чего
нельзя было избежать. Разорвалось сетевое соединение, кончились
чернила в принтере или не осталось места на диске.
2. Механизмы сообщения об ошибках
Есть несколько стандартных стратегий передачи информации об ошиб%
ке в клиентский код. Вы можете встретить код, в котором применяется
любая из них, поэтому каждый из имеющихся диалектов должен быть
вам понятен. Обратите внимание на особенности этих методов сообще%
ния об ошибках и на преимущества тех или иных из них в отдельных
ситуациях.
3. Обнаружение ошибок
Возвращаемые значения
Успешно ли выполнилась функция, определяется по возвращаемо%
му ею значению. Эта проверка на отказ тесно связана с самим вызо%
вом функции; подразумевается, что, выполняя его, вы проверяете,
был ли он успешным. Учитывать полученный результат или нет –
дело ваше.
Переменные состояния ошибки
После вызова функции нужно рассмотреть значение переменной со%
стояния ошибки. Для переменной errno в модели C нет необходимо%
сти проверять наличие ошибки после каждого обращения к функ%
ции. Сбросьте значение errno, а затем последовательно вызовите
любое число стандартных библиотечных функций. После этого по%
смотрите на значение errno. Если оно соответствует коду ошибки,
значит, одна из вызывавшихся функций дала сбой. Вы не узнаете,
какая именно, но иногда можно воспользоваться и таким упрощен%
ным способом обнаружения ошибок. 
Исключительные ситуации
Если одна из подчиненных функций сгенерировала исключитель%
ную ситуацию, вы можете либо перехватить ее, либо игнорировать
и позволить ей подняться на более высокий уровень. Обоснованное
решение можно принять лишь тогда, когда известно, какие исклю%
чительные ситуации могут генерироваться. Такое знание может
дать вам документация (если она заслуживает доверия).
В Java исключительные ситуации реализованы так, что эта доку%
ментация находится в самом коде. Программист обязан написать
для каждого метода спецификацию исключений, указав, какие ис%
ключительные ситуации могут генерироваться. Java – единствен%
ный из основных языков программирования, который предъявляет
такие требования. Исключение, отсутствующее в списке, не сможет
проскочить, потому что компилятор осуществляет статическую про%
верку с целью не допустить этого.1
Сигналы
Есть лишь один способ обнаружить сигнал: установить для него об%
работчик. Делать это необязательно. Можно не устанавливать ника%
ких обработчиков сигналов и сохранить поведение по умолчанию.
4. Обработка ошибок
Где она возникла
Это совсем не то место, где она станет обрабатываться. Где находит%
ся источник – в базовой системной компоненте или периферийном
модуле? Эти данные могут присутствовать в сообщении об ошибке
либо быть получены вручную. 
Что вы пытались сделать?
Что спровоцировало ошибку? В этом может быть ключ ко всем вос%
становительным действиям. В отчете об ошибке такие сведения
встречаются редко, но по контексту можно выяснить, какая функ%
ция была вызвана. 
Почему возник сбой
В чем суть проблемы? Нужно точно узнать, что случилось, а не про%
сто установить класс ошибки. Какая часть приведшей к ошибке
операции успела выполниться? Прекрасно, если выполнилось все
или ничего, но обычно программа оказывается в некоем промежу%
точном состоянии.
Когда это случилось
Это локализация ошибки по времени. Произошел ли отказ только
что или это проблема двухчасовой давности, известившая о себе
только сейчас? 
Степень тяжести ошибки
Одни проблемы опаснее других, хотя при обнаружении они все рав%
нозначны – не разобравшись с проблемой и не найдя ее решения,
нельзя двигаться дальше. Степень тяжести обычно определяет вы%
звавший уровень исходя из того, насколько легко возобновить рабо%
ту или найти обходной путь.
Как исправить ошибку
Решение может быть очевидным (например, вставить дискету и по%
вторить операцию) или не совсем (например, потребуется модифи%
цировать параметры функции, сделав их совместимыми). Чаще все%
го вывод делается на основании других источников информации.
5. Подымаем скандал
Мы уже довольно долго занимаемся ошибками, которыми нас снабжа%
ют другие. Пора поменяться местами и самим выступить в роли нехо%
роших мальчиков: будем генерировать ошибки. Если вы пишете функ%
цию, в ней могут происходить неправильные вещи, о которых нужно
сообщать вызывающему. И делать это необходимо – не проходите мимо
сбоев. Даже если вы уверены, что вызвавший не будет знать, что делать
с проблемой, вы должны проинформировать его. Не пишите лживый
код, который якобы делает то, чего на самом деле он не выполняет.
6. Управление ошибками
Стандартный принцип для генерации и обработки ошибок требует нали%
чия единообразной стратегии обработки сбоев, в каком бы месте они ни
проявились. Вот общие административные соображения, относящие%
ся к возникновению, обнаружению и обработке программных ошибок:
• Избегайте ситуаций, чреватых ошибками. Лучше напишите код,
который гарантированно будет работать. Например, чтобы не воз%
никало ошибок выделения памяти, заранее позаботьтесь о резерви%
ровании достаточных ресурсов. Когда у вас обеспечен пул памяти,
программа не может испытывать недостатка в памяти. Конечно,это осуществимо, только если заранее известно, сколько нужно ре%
сурсов, но часто именно так и бывает.
• Определите возможное поведение вашей программы или функции
в необычных обстоятельствах. Исходя из этого установите, на%
сколько устойчивым должен быть код и насколько тщательной –
обработка ошибок. Не получится ли так, что функция, не привле%
кая внимания, сгенерирует скверные выходные данные согласно
классическому принципу GIGO?1
• Четко распределите между компонентами обязанности по обработ%
ке тех или иных ошибок. Объявите это в интерфейсе модуля. Пусть
ваш клиент знает, что будет работать всегда, а что может в один
прекрасный день отказать.
• Проконтролируйте свой стиль программирования: в какой момент
вы пишете код обработки ошибок? Не откладывайте его на буду%
щее; обязательно что%нибудь пропустите. Не откладывайте написа%
ние обработчиков до того времени, когда тестирование выявит про%
блемы – это не инженерный подход. 
• Если вы перехватили ошибку, что это – симптом или причина? Вы
можете обнаружить источник проблемы, которую нужно исправ%
лять тут же, или признак более застарелой проблемы. В последнем
случае не нужно писать много кода в этом месте; лучше поместить
его там, где он более уместен – в более раннем обработчике ошибки.
7. Резюме
Людям свойственно ошибаться (но у компьютеров это тоже хорошо по%
лучается). Исправление ошибок – святое дело.
На всякую написанную вами строчку кода должен приходиться надле%
жащий объем кода для доскональной проверки и обработки ошибок.
Программа без строгой обработки ошибок не может быть надежной.
В один прекрасный день случится какая%то неясная ошибка, и в ре%
зультате программа рухнет.
7 глава
Инструментарий программиста
1. Что такое инструмент программирования?
Для изготовления программного обеспечения мы пользуемся широ%
ким спектром инструментов – программ, которые строят программы,
если не слишком вдаваться в философию. Все, с помощью чего мы соз%
даем программное обеспечение, является в своем роде инструментом.
Одни инструменты помогают писать код. Другие помогают писать хо#
роший код. Третьи помогают привести в порядок тот запутанный код,
который вы только что написали.
2. А зачем они нужны – инструменты?
Невозможно создавать программы без базового набора программных
инструментов; вы не сдвинетесь с места без редактора и компилятора.
Есть ряд инструментов, без которых можно обойтись, но все же они
очень полезны. Чтобы повысить свою продуктивность, качество кода
и мастерство, полезно присмотреться к инструментам, которыми вы
пользуетесь в данное время, и узнать, какие еще возможности они в се%
бе таят.
3. Электроинструменты
Программирование и применяемые в его процессе инструменты тесно
связаны между собой, поэтому, чтобы стать суперпрограммистом, вы
должны пользоваться суперинструментом. Что это значит?
Во%первых, нужно хорошо представлять себе, какие инструменты су%
ществуют. В следующем разделе мы рассмотрим список стандартных
инструментов, которые должны быть под рукой у каждого программи%
ста. Не нужно знакомиться со всеми до единого инструментами, при%
сутствующими на рынке: во всяком случае это очень скучная тема для
разговора за обедом. Важным шагом вперед будет хотя бы выяснение
того, какие общие категории инструментов существуют. Это поможет
вам сделать выбор между поиском инструмента для решения опреде%
ленной задачи, написанием собственного инструмента или выполне%
нием задачи вручную. 
Потратьте некоторое время на изучение вопроса. Узнайте, где можно
добыть какие%то из этих инструментов; существуют магазины, специа%
лизирующиеся на продаже инструментов программирования, и мно%
жество сайтов для их загрузки через Интернет. Возможно, у вас уже
стоит нужный инструмент, которым вы никогда не пользовались или
не догадывались о его ценности. Выясните, что умеют эти инструмен%
ты; в результате вы сможете воспользоваться ими с бо]льшей эффек%
тивностью.
4. Какой инструмент необходим?
Ассортимент инструментов для разработки программ ошеломляет.
Потребности, которые часто возникают, известны, и за годы развития
набралось много инструментов, удовлетворяющих любые прихоти. Ес%
ли какая%то задача возникает многократно, можете быть уверены, что
кто%то уже написал инструментарий для ее решения.
5. Резюме
Инструменты обеспечивают возможность создания программного обе%
спечения. Хорошие инструменты значительно облегчают эту задачу.
8 глава
Время испытаний
1. Проверка на подлинность 
Два простых вопроса – Что такое тестирование? и Зачем нужно тес#
тирование? – кажутся до боли очевидными. И тем не менее очень час%
то тестирование осуществляется неправильно или на неправильно вы%
бранном этапе разработки. Умелое тестирование – это искусство. Ре%
альное проведение тестирования – это уровень, которого многие про%
граммисты не достигают; от одного упоминания о тестировании они
покрываются холодным потом. «В тестировании главное правило –
это провести его»
2. Кто, что, когда, зачем?
Чтобы тестирование программного обеспечения было эффективным,
нужно разобраться, для чего мы тестируем, кто этим занимается, что
подразумевает эта процедура и когда можно считать ее законченной.
3. Тестировать легко…
Легко, если делать это плохо, иначе это тяжелый труд. Однако это не
бездумный процесс. Чтобы проверить работоспособность конкретного
фрагмента кода, требуется оснастка, которая демонстрирует: 
• Корректность выходных данных при всевозможных допустимых
вариантах входных.
• Обработку отказа при вводе любых недопустимых данных.
4. Типы тестирования
Есть много разновидностей программных тестов, и ни один из них не
обладает превосходством над остальными. В каждом методе код рас%
сматривается с определенной стороны и выполняется поиск опреде%
ленного класса ошибок. Все тесты необходимы.
5. Выбор контрольных примеров 
для блочного тестирования
Если тестировать нужно, но полное тестирование невозможно, следует
разумно выбрать комплект наиболее эффективных тестов. Для этого
вам понадобится продуманный, методичный план. Можно выбрать
подход стрельбы дробью – повесьте код на стену, а потом стреляйте по
нему из всего, что попадется под руку…
6. Архитектура и тестирование 
Качество написанных вами блочных тестов в значительной степени за%
висит от качества интерфейса, который необходимо протестировать.
Тестирование проще проводить, если вы пишете код именно в расчете
на верификацию и контроль качества. Это достигается с помощью по%
нятных API, уменьшения зависимости от других участков кода и недо%
пущения жестких ссылок на другие компоненты. В результате оказы%
вается проще поместить компоненту в тестовую среду и смоделировать
ее. Если же, напротив, она тесно связана с другими секциями кода,
вам придется переносить эти секции в среду тестирования и организо%
вывать надлежащее взаимодействие секций с вашим блоком. Иногда
это не только трудно, но просто невозможно, что ограничивает ваши
возможности тестирования.
7. Руками не трогать! 
Невозможно заниматься целый день только управлением вручную все%
ми механизмами тестирования. Запуск вручную одного теста за другим
плохо согласуется с моим представлением об эффективной работе про%
граммиста. Многократное повторение регрессивных тестов быстро на%
скучивает. И это не просто скучно, но медленно, неэффективно и под%
вержено ошибкам. Золотое правило тестирования: автоматизируй.
8. Анатомия провала
Как вы поступите, если тестирование обнаружит ошибку в програм%
ме? Прежде чем сломя голову бросаться отлаживать ее, задержитесь
и оцените проблему. Это особенно важно, если вы не хотите (или не мо%
жете) исправить ошибку сразу. Чтобы точно определить суть пробле%
мы, что позволит вам или другому разработчику в будущем вернуться
и решить ее, действуйте следующим образом: 
1. Запишите, что вы пытались сделать в тот момент и какие действия
вызвали сбой.
2. Попробуйте их повторить. Выясните, можно ли воспроизвести про%
блему, как часто она возникает и не выполняются ли в то же время
какие%то другие действия.
3. Опишите сбой. Полностью. Будьте предельно конкретны. Включи%
те следующее:
• контекст проблемы;
• простейший способ ее воспроизведения;
• сведения о повторяемости и частоте возникновения;
• версию программного обеспечения, точный номер сборки и ис%
пользовавшееся оборудование;
• все остальное, что предположительно могло бы иметь отношение.
4. Запишите все и не теряйте! Занесите данные в систему контроля
ошибок, даже если это простая ошибка в коде, которую вы собирае%
тесь исправить сами (см. ниже раздел «Справлюсь ли я сам?»)
5. Напишите простейший контрольный пример, демонстрирующий
сбой, и добавьте его в набор автоматически выполняемых тестов.
Этим вы гарантируете, что ошибка не будет потеряна или забыта,
а когда она будет исправлена, но не повторится в новых разработках. 
9. Справлюсь ли я сам?
Для поиска ошибок требуются методичность и систематичность. Мето%
дичность и систематичность нужны также для учета и управления уст%
ранением ошибок. До того как код выпущен или попал в систему кон%
троля версий, единственный, кто испытывает неприятности из%за этой
ошибки, – вы сами. Но как только вы выпустили код на свободу, он на%
чинает жить своей жизнью. И ошибки в нем касаются уже не только
вас. По мере вступления в игру новых участников правила меняются:
• Программист находит проблемы, глядя на код – свой собственный
или чужой.
• Интегратор кода обнаруживает ошибки в ходе соединения отдель%
ных компонент.
• Отдел QA обнаруживает ошибки во время тестирования.
10. Резюме 
Тестирование – необходимый элемент для создания хорошего про%
граммного продукта. В целом, чем больше тестирования, тем лучше –
хотя на качестве конечного продукта отражается и качество тестов.
Плохие тесты обнаружат мало ошибок, и в результате вы выпустите
продукт с дефектами.
9 глава
Поиск ошибок
1. Реальные факты
Не думаю, что кто%нибудь усаживает студентов%программистов и объ%
ясняет им, как устроена жизнь: «Видишь ли сынок, есть птички
и пчелки. Ах да, забыл про жучков.» «Жучки», или «баги», – это неиз%
менная мрачная сторона создания программ, неизбежная реальность.
Печально, но это так. Существуют целые отделы, даже специальности,
поставленные на борьбу с ними.
2. Природа этого зверя
Вопреки распространенному мнению термин жучок (bug) был в ходу
еще до появления компьютеров. В 1870%х годах Томас Эдисон говорил
о жучках в электрических цепях. История с релейной вычислительной
машиной Mark II Aiken Гарвардского университета является первым
зарегистрированным случаем компьютерного жучка. В 1945 году, ко%
гда первые компьютеры были таких размеров, что занимали целую
комнату, в одно такое помещение залетела бабочка и, сев на какие%то
провода, вызвала аварию системы. В журнале оператора была сделана
запись о первом реальном случае обнаружения компьютерного жучка.
Это событие увековечено экспонатом Смитсоновского института.
3. Борьба с вредителями
Выдергивать сорняки из программ трудно. Нужно обнаружить ошиб%
ку, распознать проблему, искоренить все следы нежелательного пове%
дения, проверить, не проникла ли ошибка в другие места, и постарать%
ся не испортить ничего в коде, проводя все эти действия. Даже первый
шаг – обнаружение ошибки – представляет собой большое затрудне%
ние: человек совершает ошибки при письме, но не меньшее их количе%
ство он делает при чтении. Читая свой текст или код, я, естественно,
вижу то, что хотел написать, а не то, что написал в действительно#
сти. Ошибки в коде не бросаются в глаза. От компилятора помощи то%
же немного; он действует весьма педантично. Компилятор сделает
в точности то, о чем вы просили, а не то, что вы подразумевали.
4. Охота за ошибками
Как искать ошибки? Если бы существовала какая%нибудь простая
трехшаговая процедура, мы бы ее выучили и стали выпускать идеаль%
ные программы. Нет такой процедуры, и наши программы такие, ка%
кие они есть. Попробуем разобраться в опыте поиска ошибок, накоп%
ленном человечеством.
5. Как исправлять ошибки
Этот раздел, как вы заметите, гораздо меньше предыдущего. Как ни
странно. Обычно главную часть проблемы составляет поиск проклятой
ошибки. После того как вы вычислили, где она лежит, исправить ее
можно очевидным образом. 
6. Профилактика 
Всякий скажет вам, что «предохраняться – эффективнее, чем лечить%
ся». Лучший способ не множить ошибки – это не допускать их возник%
новения изначально. К несчастью, я не надеюсь, что мы когда%нибудь
достигнем этого идеала. Поскольку программирование подразумевает
решение задач, оно всегда будет сложным занятием; вы не только
должны правильно решить задачу, но прежде всего должны понимать
задачу в целом. Несмотря на это, тщательно проводимое защитное
программирование позволяет избежать многих проблем. Хороший
стиль программирования подразумевает дисциплину и внимание к де%
талям. Тщательное тестирование предотвращает проникновение оши%
бок в окончательные версии программных продуктов.
7. Спрей от ос, репеллент для мух, липучки…
Есть много полезных средств отладки, и глупо отказываться от них.
Одни интерактивны и позволяют изучать код во время его выполне%
ния, другие неинтерактивны и часто действуют как фильтр кода или
анализатор, выводящий информацию об анализируемой программе.
Научитесь ими пользоваться, и это неизмеримо сократит время, кото%
рое вы тратите на отладку.
8. Резюме
Как смерти и налогов, мы при всех стараниях не сможем избежать
ошибок. Конечно, эффект первых двух обстоятельств можно умерить,
если не упускать из виду ни один новый крем против морщин или при%
менять хитрые финансовые схемы, но если вы не знаете, как посту%
пить, столкнувшись со сбоями в вашей программе, ваш код обречен.
10 глава
Код, который построил Джек 
1. Языковые барьеры
Есть несколько разновидностей языков программирования, в каждой
из которых существует своя механическая процедура построения ис%
полняемой программы из исходного кода. Модели построения разли%
чаются по сложности, и у каждой есть свои сильные и слабые стороны.
2. Делаем слона из мухи
Модели компиляции (и компиляции в байт%коды) сложнее всего в об%
суждении, поэтому рассмотрим, что включает в себя компиляция про%
граммного обеспечения. Просто поразительно, как мало начинающих
программистов действительно понимает это, поэтому мы начнем с ба%
зовых принципов. Если эта тема вам знакома, можете пропустить ее.
3. Выполнение сборки
Мы рассмотрели некоторые главные моменты построения сборки про%
граммы в этом засасывающем болоте создания программного продук%
та. В сущности, в любой процедуре сборки программы есть один или
несколько файлов с исходным кодом на входе и некая выполняемая
программа на выходе. Результатом может быть даже полный дистри%
бутив программы, включая выполняемый файл, файлы подсказки,
программу установки и т. д., которые будут тщательно упакованы
и готовы к записи на CD.
4. Механика сборки 
За этими соображениями качества стоят практические вопросы систе%
мы сборки. Чтобы поговорить о них конкретно, мы подробно обсудим
make, конкретную систему сборки и make%файлы, но не пугайтесь – за
исключением различий в синтаксисе, другие системы сборки следуют
аналогичным соглашениям (даже красивые графические пакеты). 
5. Отпусти меня…
Некоторые сборки имеют особую важность и требуют более тщатель%
ной подготовки. Это финальные сборки, выполняемые со специальной
задачей, а не в ходе разработки. Финальная сборка может быть связа%
на с волнующим событием: выпуском бета%версии, первым официаль%
ным выпуском продукта или выпуском обновления продукта. Это так%
же может быть внутренняя контрольная версия разработчика или про%
межуточная версия для отдела тестирования; такие версии не выходят
за стены компании, но отношение к ним такое же серьезное, как к вы%
пускаемым версиям – что%то вроде учебной тревоги перед окончатель%
ным выпуском.
6. Мастер на все руки
Во многих организациях есть конкретный работник, занимающийся
сборкой, которого часто называют мастером сборки (buildmaster). Его
работа состоит в сопровождении системы сборки. В его обязанности
могут входить планирование и реализация графиков сборки, либо он
выполняет чисто технические функции. Мастер сборки должен глубо%
ко разбираться в системе сборки. Он может настраивать систему, до%
бавлять в нее нужные новые цели, сопровождать сценарии ночной
сборки и т. д. Мастер сборки также ведет документацию по системе
сборки, а возможно, и администрирует систему контроля версий.
7. Резюме
На первый взгляд кажется, что в процедуре сборки программного
обеспечения нет ничего сложного, если правильно выбрать инструмен%
ты. Но этими инструментами нужно уметь пользоваться. Качество
системы сборки имеет первостепенное значение; в отсутствие безопас%
ной, надежной процедуры сборки разработать крепкий код невозмож%
но. Выпустить надежный конечный продукт еще сложнее – для этого
требуются тщательность и точность процедуры. Важно разбираться
в том, как работает система сборки, даже если не требуется ежедневно
вносить в нее изменения.
11 глава
Жажда скорости
1. Что такое оптимизация?
Оптимизация подразумевает улучшение чего%либо, усовершенствова%
ние. В нашем деле она обычно означает, что «код станет выполняться
быстрее», если мерить производительность программы с секундомером.
Но это лишь одна сторона. У разных программ разные требования, и что
«хорошо» для одной, не обязательно «хорошо» для другой. На практике
оптимизация программного обеспечения может иметь разный смысл: 
• Увеличение скорости выполнения программы
• Уменьшение размера исполняемого модуля
• Совершенствование качества кода
• Повышение точности результатов
• Сокращение времени запуска
• Увеличение производительности обработки данных (не обязательно
связанное с ростом скорости выполнения)
• Уменьшение расходов на хранение данных (например, уменьшение
размера базы данных) 
2. От чего страдает оптимальность кода?
Чтобы улучшить свой код, нужно знать, отчего он может работать мед%
ленно, неоправданно расти в размере или иным образом терять качество.
В дальнейшем это поможет нам предложить некоторые методы оптими%
зации кода. Но сейчас полезно уяснить, с чем мы собираемся бороться.
Сложность
Неоправданная сложность губит код. Чем больше работы должен
сделать код, тем медленнее он будет выполняться. Сокращение объ%
ема работ или разбиение задачи на несколько более простых и ко%
ротких могут значительно повысить производительность.
Косвенность 
Превозносится как решение всех проблем программирования и фор%
мулируется в виде известной программистской максимы: любую
проблему можно решить, добавив уровень косвенности. Но косвен%
ность также часто является причиной медлительности кода. Эта
критика часто звучит со стороны процедурных программистов ста%
рого закала в адрес современного OO%проектирования. 
Повторение 
Повторение обязательно снижает эффективность кода, но часто его
можно избежать. Оно случается в разных формах, например, если
не сохранять в буфере результаты трудоемких вычислений или вы%
зовов удаленных процедур. При каждом повторно выполненном
вычислении вы теряете эффективность. Повторение участков кода
неоправданно увеличивает размер выполняемого модуля.
Плохой проект
Это неизбежно: плохое проектирование приводит к плохому коду.
Например, если разнести далеко друг от друга связанные блоки (ска%
жем, разместив их в разных модулях), то их взаимодействие замед%
лится. Плохой проект может привести к возникновению фундамен%
тальных, очень тонких и сложных проблем с производительностью.
Ввод/вывод
Взаимодействие программы с внешним миром – ее ввод и вывод –
это известное узкое место. Если выполнение программы блокирует%
ся в ожидании ввода или вывода данных (пользователем, с диска
или через сеть), она неизбежно теряет в производительности.
3. Доводы против оптимизации
В прежние времена оптимизация имела огромное значение, поскольку
первые компьютеры работали крайне медленно. Чтобы заставить про%
грамму выполниться в течение разумного промежутка времени, требо%
вались высокое мастерство и тонкая шлифовка отдельных машинных
команд. Сейчас такое мастерство утратило былую ценность; револю%
ция, осуществленная персональными компьютерами, изменила харак%
тер разработки программ. Часто мы располагаем избытком вычисли%
тельной мощи – в полную противоположность минувшим временам.
Может сложиться впечатление, что оптимизация больше не нужна.
4. Нужна ли оптимизация
Уяснив, что с оптимизацией связаны опасности, не выкинуть ли на%
всегда из головы идею оптимизировать свой код? Не стоит. Хотя опти%
мизации следует по возможности избегать, однако во многих случаях
она весьма важна. И есть области, в которых она оказывается просто
необходимой.
5. Технические подробности
Каким же образом выполнять оптимизацию? Гораздо важнее уяснить
правильный подход к оптимизации, чем выучить список конкретных
методов. Не бойтесь, мы рассмотрим ниже некоторые приемы про%
граммирования, но их следует рассматривать в контексте более широ%
кой процедуры оптимизации. 
Вот шесть этапов для повышения скорости работы вашей программы:
1. Убедитесь, что программа слишком медленно работает и требует
оптимизации.
2. Определите, какая часть кода самая медленная, и нацельте на нее
свои усилия. 
3. Проверьте производительность кода, выбранного для оптимизации. 
4. Оптимизируйте код. 
5. Протестируйте оптимизированный код и убедитесь, что он сохра%
нил работоспособность (очень существенно). 
6. Проверьте, насколько выросла скорость, и решите, что делать
дальше.
6.Методы оптимизации
Мы долго обсуждали общие вопросы; пора заняться конкретными де%
талями. Следуя описанной выше процедуре оптимизации, вы убеди%
лись, что программа работает неэффективно, и нашли код, больше все%
го повинный в этом. Необходимо переделать его. Что для этого нужно?
 Существуют различные виды оптимизации. Какой из них подойдет
в вашем случае, зависит от конкретной проблемы, вашей цели (напри%
мер, увеличить скорость или уменьшить размер кода) и требуемой сте%
пени оптимизации.
7. Как писать эффективный код 
Если лучше всего отказаться от оптимизации, то как достичь того,
чтобы потребности в повышении эффективности кода вообще не воз%
никало? Для этого нужно проектировать код с учетом его эффектив#
ности и планировать надлежащее качество его работы с самого нача%
ла, а не обстругивать его в последнюю минуту.
8. Резюме
Высокая эффективность кода не столь важна, как некоторым кажет%
ся. Хотя иногда приходится засучить рукава и поковыряться в коде,
в целом нужно активно избегать проведения оптимизации. Поэтому до
начала работы над программным продуктом выясните, какие требова%
ния предъявляются к его производительности. На каждом этапе раз%
работки проверяйте, обеспечивается ли требуемое качество. Тогда оп%
тимизация вам не понадобится. 
12 глава
Комплекс незащищенности
1. Риски
Кому может понадобиться атаковать вашу систему? Тому, кто захочет
воспользоваться тем, чем вы располагаете. Это могут быть: 
• Вычислительные мощности.
• Возможность отправки данных (например, для рассылки спама).
• Ваши конфиденциальные данные.
• Ваши возможности, например определенное программное обеспече%
ние, которое у вас установлено.
• Ваше подключение к представляющим интерес удаленным системам.
2.Наши оппоненты 
Вероятно, трудно поверить в то, что кто%то не пожалеет сил и времени,
чтобы попытаться взломать ваше приложение. Но такие люди есть.
Они талантливы, целеустремленны и весьма терпеливы. Если вы хоти%
те писать защищенные программы, следует знать своего противника.
Тщательно разберитесь в том, что они делают, как это делают, какими
инструментами пользуются и какие задачи перед собой ставят. Только
тогда вы сможете выработать правильную стратегию.
3. Оправдания, оправдания 
Как же атакующим удается так часто взламывать код? Они располага%
ют оружием, которого у нас нет или о котором мы по недостатку обра%
зования ничего не знаем. Инструменты, знания, мастерство – все это
работает на них. Однако они располагают еще одним основополагаю%
щим преимуществом – временем. В условиях промышленного произ%
водства программного продукта разработчики вынуждены вырабаты%
вать максимальный объем кода, который только доступен их силам
(или даже больше), и делать это в сжатые сроки, в противном случае
последствия известны. Этот код должен удовлетворять определенным
требованиям (функциональности, юзабилити, надежности и т. п.), а это
оставляет крайне мало времени на заботу о «второстепенных» качест%
вах, таких как защищенность. У атакующих таких проблем нет; у них
достаточно времени, чтобы изучить все хитрости вашей системы, и
они научились нападать с разных сторон.
4. Ощущение незащищенности
Задача программиста во всей этой сумятице – написать защищенный
код, поэтому проведем обзор слабых мест в наших программах, чтобы
определить, куда направить свои усилия. Существуют конкретные ви%
ды уязвимостей в коде – брешей, которыми может воспользоваться
атакующий.
5. Дела защитные
Стратегии защиты программного обеспечения применимы на разных
уровнях:
Установка системы
Конкретная конфигурация ОС, инфраструктура сети, номера вер%
сий всех работающих приложений имеют важное значение для со%
стояния безопасности.
Конструктивные особенности программной системы
Необходимо принять правильные конструктивные решения, на%
пример, относительно возможности для пользователя оставаться
зарегистрированным в системе произвольно долгое время, способов
связи между подсистемами, выбора протоколов.
Реализация программы
В ней не должно быть дефектов. Наличие ошибок в коде может
быть причиной уязвимости системы.
Процедура эксплуатации системы
При неправильном использовании любая система может представ%
лять собой угрозу. По возможности этому должно препятствовать
правильное проектирование, но пользователям нужно объяснить,
какие их действия могут привести к проблемам. Ведь сколько лю%
дей записывают свое имя и пароль на бумажке, которую кладут ря%
дом с терминалом!
6.Резюме
Программирование – это война.
Безопасность – серьезная проблема в разработке современного про%
граммного обеспечения; невозможно спрятать голову в песок, чтобы
не замечать ее. Страусы пишут плохой код. С брешами в системе без%
опасности можно бороться с помощью более тщательного проектиро%
вания и совершенствования архитектуры системы, а также лучшего
информирования о существующих проблемах. Слишком велики рис%
ки, чтобы позволить себе не думать о защищенности систем.
13 глава
Важность проектирования
1. Программирование как конструкторская работа
Распространено мнение, что «проектирование» – это этап, который
должен быть завершен перед началом написания кода. Его результа%
том является спецификация проекта в той или иной форме, которую
сможет реализовать любой ремесленник.
На самом деле все совсем иначе. Программирование – действие, за%
ключающееся в написании кода, – представляет собой конструктор#
скую работу.
2. Что нужно проектировать? 
Очевидно, программисты проектируют кодовые структуры. Но на раз%
ных стадиях разработки это может иметь разный смысл. На любой
стадии проектирование заключается в разделении задачи на состав%
ные части и определении того, как работает каждая часть.
3. Из-за чего весь этот шум?
Никто не станет утверждать, что проектировать нужно плохо, и тем не
менее плохо спроектированного кода предостаточно. Проведя несколь%
ко лет на линии фронта, любой разработчик подтвердит вам это своими
шрамами. (Закаленные в сражениях ветераны уже кивают головами
и мысленно готовятся рассказать случаи из своего боевого прошлого.)
4. Хороший проект программного продукта 
Любая задача программирования допускает несколько вариантов про%
екта кода. Вы должны выбрать из них один. Лучший. Или хотя бы
достаточно хороший. Это не так просто…
• Как определить, что ваш проект жизнеспособен? Выработав безу%
пречный план проведения атаки, вы уверенно приступаете к его
реализации. Через какое%то время вы сталкиваетесь с неожиданной
проблемой. Назад к чертежной доске!
• Как определить, что проект завершен? Это станет известно только
тогда, когда вы действительно реализуете его и убедитесь в том, что
он работает. Многие проблемы нельзя предвидеть загодя; нужно
осуществить реализацию проекта и выяснить, работает ли она.
Только опробовав некоторое решение, вы по%настоящему начинаете
понимать исходную задачу. Вооружившись накопленным опытом,
вы можете теперь попробовать решить ее правильно.
• Как определить, что выбранное вами конструктивное решение яв%
ляется лучшим из существующих? Это можно сделать только после
того, как вы опробуете все варианты. На практике это неосуществи%
мо. Как тогда определить, что ваше решение приемлемо? Если
предъявляются требования к производительности, то оценить свое
решение вы сможете лишь тогда, когда система заработает.
5. Как проектировать код
Как научиться правильно проектировать? Хорошими проектировщи%
ками становятся или рождаются? Можно ли обучать проектированию
и можно ли перенять это искусство? У программистов бывает природ%
ное чутье на хороший проект; так устроены их мозги. Они от природы
эстетически развиты и способны в достаточной мере разобраться в про%
блеме, чтобы выносить здравые суждения. Тем не менее эффективно%
му проектированию можно научиться.
6. Резюме
Хороший код правильно спроектирован. Он обладает некой эстетиче%
ской привлекательностью, которая располагает к нему. Прежде чем
писать код, нужно составить его проект, иначе в итоге получится ма%
лоприятная путаница. Принимайте во внимание такие аспекты, как
понятная структура, возможность расширения в будущем, коррект%
ные интерфейсы, уместная абстракция и переносимость на другие
платформы. Стремитесь к простоте и элегантности.
14 глава
Программная архитектура
1. Что такое программная архитектура?
Может быть, это еще один термин, который с большей натяжкой про%
должает метафору строительства зданий? Возможно, но это дейст%
вительно полезная концепция. Программную архитектуру иногда еще
называют проектированием верхнего уровня. Термин архитектура
лучше ассоциируется с идеями, заложенными в этой процедуре.
2. Какими качествами должна обладать 
архитектура?
Ключ к созданию хорошей архитектуры – простота. Задача в том,
чтобы правильно выбрать несколько модулей и разумно организовать
между ними связь. Архитектура также должна быть понятной, что
часто означает наглядность представления. Всем известно, что лучше
один раз увидеть, чем сто раз услышать.
3. Архитектурные стили
Подобно тому как огромный готический собор, причудливая виктори%
анская часовня, внушительный квартал высотных зданий и общест%
венный туалет 70%х представляют собой различные архитектурные
стили, существует ряд признанных стилей в архитектуре программно%
го обеспечения, в соответствии с которыми может строиться система.
Выбор стиля может быть обусловлен многими причинами, не всегда
вескими. Например, он может осуществляться исходя из прочных тех%
нологических обоснований, прежнего опыта работы архитектора и да%
же соображений моды. Каждой архитектуре свойственен определен%
ный набор свойств: 
• Устойчивость к изменениям в представлении данных, в алгоритмах
и необходимых функциях
• Способ разделения и соединения модулей
• Удобопонятность
• Приспосабливаемость к требованиям производительности
• Возможность повторного использования компонент
4.Резюме
Римский архитектор Витрувий сделал бессмертное высказывание по
поводу того, что составляет хороший архитектурный проект: проч%
ность (firmitas), полезность (utilitas) и красота (venustas). Это вполне
справедливо в отношении архитектуры программного обеспечения.
В отсутствие четко определенной архитектуры с четкими коммуника%
циями программному проекту будет не хватать связной внутренней
структуры. Он станет хрупким, нестабильным и уродливым. В конеч%
ном итоге в нем возникнут разрушительные напряжения.
15 глава
Программное обеспечение – 
эволюция или революция?
1. Гниение программного обеспечения
С хорошим кодом происходят плохие вещи. Каким бы удачным ни бы%
ло начало, какими бы достойными ни были ваши намерения, каким
бы ясным ни был ваш проект и какой бы четкой ни была реализация
в первой версии, время будет разрушать и корежить ваш шедевр. Все%
гда помните про способность кода накапливать бородавки и шрамы на
протяжении своей жизни.
2. Тревожные симптомы
Постоянно анализируйте код в поисках признаков деградации. Следи%
те за появлением тревожных признаков: деградация начинается с лю%
бых изменений, приводящих к потере ясности или усложнению систе%
мы. Неоправданная сложность скрывается под разными масками.
Вот что должно восприниматься как мигающие красные огни и вой
клаксонов: 
• Код перегружен многочисленными крупными классами и запутан%
ными функциями.
• Имена функций загадочны или обманчивы. У функций проявляются
неожиданные побочные эффекты, не предусмотренные их именами.
• Отсутствует структура: непонятно, где искать нужную функцию.
• Есть дублирование: оказывается, что отдельные фрагменты кода
занимаются одним и тем же.
• Высока степень связанности: сложные соединения и взаимозависи%
мости модулей приводят к тому, что небольшие изменения в одном
месте вызывают широкие отголоски во всем коде – иногда в моду%
лях, которые, как казалось, независимы. (См. раздел «Модуль%
ность» на стр. 325).
• Проходящие через систему данные многократно преобразуются из
одного представления в другое (например, отображаемые данные
передаются между std::string, char*, Unicode, UTF%8 и обратно). 
• API становятся расплывчатыми; некогда четкие интерфейсы стали
слишком широкими по охвату в результате непродуманного добав%
ления новых функций.
• API резко меняются от одной версии кода к другой.
• Элементы закрытой реализации просачиваются в открытые API ра%
ди изготовления быстрых заплаток.
• Код замусорен обходными путями: признак лечения симптомов, а не
болезней. Под ними скрываются реальные проблемы. По краям сис%
темы громоздятся обходные пути, а проблемы притаились в центре.
• Есть функции с громадными списками параметров. Многие из них
не используют эти параметры, а передают во вспомогательные
функции.
• Попадается код, об усовершенствовании которого даже страшно по%
думать. Неизвестно, каков будет результат – улучшение работы,
скрытая поломка или нечто худшее.
• Новые функции добавляются без соответствующей документации;
имеющаяся документация устарела.
• При компиляции кода выводится множество предупредительных
сообщений.
• Встречаются комментарии, гласящие здесь ничего не трогать…
3. Как развивается код?
Никакие разработки не следуют до конца классической модели: за%
фиксировать окончательно все технические требования, полностью
разработать проект, полностью написать код, выполнить интеграцию,
протестировать и выпустить готовый продукт. В существующем базо%
вом коде приходится делать неожиданные модификации. Каким%то
образом прилепляются новые части. Это расширяющийся цикл разра%
ботки для достижения постоянно меняющихся целей.
4. Вера в невозможное
Возможно, мы потому так часто сталкиваемся с плохим кодом и мно%
гочисленными небрежными заплатками, что существует ошибочное
мнение, будто правильный подход к работе отнимает больше времени.
Это мнение будет опровергнуто, если учесть сокращение времени от%
ладки и простоту последующих модификаций. Можно быстро среаги%
ровать на сообщение об ошибке, внеся исправление на скорую руку, но
это не лучшее решение. Настоящий мастер ответственно относится
к модификации кода.
5. Как с этим бороться? 
Теперь, определив некоторые проблемы, связанные с развитием базо%
вого кода, мы встаем перед вопросом, как с ними справляться. Какую
стратегию выбрать, чтобы избежать путаницы?
Первое и главное – признать существование проблемы. Очень многие
программисты латают код, не задумываясь о качестве результата. Ес%
ли им удается в кратчайшие сроки успокоить возмущенных пользова%
телей, их не волнует, в каком состоянии после них остается код. В сле%
дующий раз им будет заниматься кто%то другой.
6. Резюме
Я бы не согласился с Аристотелем. Перемены могут оказаться сущим
мучением. Изменения в коде нужно проводить с большой осторожно%
стью. Тогда программа будет развиваться в лучшую сторону, а не де%
градировать в неустойчивое бесформенное образование. 
Необходимо правильно сопровождать и расширять приложение, со%
храняя организацию кода и осуществляя не вызывающие отторжения
модификации. Сопровождение – нелегкая задача. Переписывание, пе%
репроектирование и рефакторинг могут потребовать больших затрат
времени.
16 глава
Кодеры
1. Мартышкин труд
Обитатели фабрики программного обеспечения – странное собрание
чудаков и слабо пригодных к общественной жизни людей, программи#
стов (code monkeys). Все серьезные программные системы создаются
горсткой таких людей, у каждого из которых свой уровень мастерства
и склад ума, но все они работают над достижением общей цели.
2. Идеальный программист
Политик 
Он должен быть дипломатом и мудро относиться к огрехам этих
странных кодеров и многочисленных прочих обитателей программ%
ного производства – менеджеров, тестеров, вспомогательного пер%
сонала, клиентов, пользователей и т. д.
Коммуникатор 
Он хорошо срабатывается с людьми. Не ограничивается своей ча%
стью проекта и готов взяться за другую задачу, если это идет на об%
щую пользу. Он хороший собеседник – умеет слушать других и вы%
сказаться сам.
Художник
Умеет разрабатывать элегантные решения и ценить эстетическую
сторону хорошо исполненной реализации.
Технический гений
Пишет надежный, промышленного качества код. Его технические
знания разнообразны, и он умеет их применять в нужном месте.
Перечитывая этот список, вы понимаете, к чему мы должны стремиться. 
3. И что из этого следует?
Занятно было поглядеть на клетки, в которых сидят эти «code mon%
keys», и посмеяться над ними. Но какой из этого всего вывод? Если не
сделать его, значит, все было лишь развлечением, и после всего прочи%
танного вы и дальше станете совершать те же глупости, что и раньше.
Чтобы стать лучше как программист, нужно измениться. Меняться
тяжело – это противоречит нашей природе. Как говорится, может ли
леопард изменить пятна свои? Если бы мог, это был бы уже не лео%
пард. Возможно, в этом разгадка. Побольше бы было среди нас анти%
лоп гну или носорогов.
4. Для глупцов 
Какие выводы нужно сделать из описаний каждого типа программи%
стов, чтобы помочь нам определить необходимые изменения? У всех
есть личные недостатки, но в приводимой классификации перечисле%
ны некоторые положительные черты и ряд областей, в которых обыч%
но следует совершенствоваться. Чтобы стать хорошим программи%
стом, нужно выработать в себе следующие качества: 
Умение работать в команде
Научитесь эффективно сотрудничать. Попробуйте разобраться, ка%
кими особенностями характера обладает каждый из ваших коллег,
и учитывайте их в общении с ними.
Честность и скромность
Реалистично оценивайте свои способности: нужно знать свои силь%
ные и слабые стороны. Не прикидывайтесь более способным, чем
вы есть на самом деле. Выработайте в себе готовность помогать лю%
дям и эффективно работать с ними.
Постоянное самосовершенствование
Какими бы обширными ни были ваши знания и опыт, как бы хорош
ни был ваш код, всегда есть то, чего вы не знаете или не умеете,
и есть неправильные позиции, которые следует поменять. Как ска%
зал Конфуций: «Настоящее знание заключается в понимании разме%
ров своего невежества». Согласитесь с тем, что у вас есть недостатки.
Хороший программист постоянно занят самосовершенствованием.
Внимательность
Привыкните всегда думать, прежде чем что%то делать. Причиной
глупых ошибок является невнимательность. Думайте головой.
Прежде чем написать любой фрагмент кода, обдумайте свои дейст%
вия. Перечитывайте написанное, даже если это небольшая модифи%
кация.
Увлеченность 
Старайтесь поддерживать в себе такой же энтузиазм, как у Нетер%
пеливого программиста. Если вы любите приобретать новые навы%
ки, больше читайте и практикуйтесь. Если вам периодически тре%
буется делать перерыв в работе, запланируйте себе хороший отдых!
Если вы получаете удовольствие от решения новых проблем, най%
дите себе такую работу, которая будет вас возбуждать.
Если вы станете степенным и скучным, ваша социальная позиция
ослабнет, а качество кода снизится.
5. Резюме
Программисты – животные общественные (несмотря на их неумение
общаться). Их общежитие вызвано необходимостью: невозможно соз%
давать замечательные и большие программные системы, иначе как ко%
мандами тесно сотрудничающих программистов, входящими в более
крупные социальные структуры (будь то отдел, компания или культу%
ра открытого программного обеспечения). 
17 глава
Вместе мы – сила
1. Команды – общий взгляд
Известно много типов команд, занимающихся разработкой программ%
ных продуктов. На одном конце спектра находятся команды со строги%
ми официальными правилами (ношением костюмов на работе), жест%
кими структурами и регламентированным рабочим процессом, а на
другом – стиль, свойственный движению open source, когда предста%
вить свой код могут все желающие, а в продукт он включается в зави%
симости от его достоинств.
2. Организация команды
Структура команды разработчиков определяется методами руковод%
ства и распределением обязанностей среди ее членов. Эти два фактора,
как и следовало ожидать, определяют объем кода и размер тех частей,
над которыми вы работаете. Отсюда видно, что код, который мы созда%
ем, зависит от организации наших команд.
3. Инструменты для групповой работы
Существуют базовые инструменты, помогающие организовать дейст%
венную команду разработчиков. Они облегчают сотрудничество и пре%
вращают совместную разработку из хаоса в отлаженный механизм.
Сами по себе они не превратят вашу группу в отряд командос, но это
арсенал, которым необходимо располагать каждой классной команде, –
необходимая предпосылка эффективного совместного труда разработ%
чиков.
4. Болезни, которым подвержены команды
Даже при наличии хороших программистов и замечательной органи%
зации команда может оказаться неработоспособной. Есть много при%
чин, по которым команды оказываются неспособными решать свои за%
дачи, и мы можем выделить категории обреченных на провал команд
так же, как выделили стереотипы программистов, и попытаться сде%
лать из этого выводы.
Ниже приводятся некоторые классические типы неудачных команд.
Для каждого из них мы опишем: 
• Специфический путь к провалу
• Симптомы (по которым вы сможете узнать, что вас ожидает)
• Как вытащить команду, попавшую в эту колею
• Как остаться успешным программистом в условиях неудачной ко%
манды (иногда вопреки команде)
5. Личное мастерство и качества, 
необходимые для работы в команде
Конечно, не все такие команды обречены. Попробуем разобраться, что
можно извлечь из этой ситуации и как ее поправить. В оставшейся
части главы мы рассмотрим приемы, которые помогут улучшить рабо%
ту вашей команды программистов и избежать отмеченных ловушек.
Хотя инструменты и технологии действительно помогают повысить
производительность, но наибольший прирост лежит в сфере человече%
ского фактора и отношения людей к своей работе.
6. Принципы групповой работы
Ниже приводятся основные заповеди командной работы, которые, бу%
дучи надежно усвоены командой, изменят ваш стиль работы. Они пе%
реносят центр внимания с отдельных личностей на программное обес%
печение и его коллективную разработку. Запомните: для того чтобы
эти принципы принесли пользу вашей команде, вы должны решитель%
но осуществить соответствующие перемены, а не просто согласиться
с ними и продолжать кодировать по%старому.
7. Жизненный цикл команды
Рассмотрим наши команды программистов с точки зрения того, как
протекает их жизнь. Команды не возникают из воздуха и не существу%
ют вечно.В жизненном цикле команды есть четыре стадии: создание, рост, рабо%
та и закрытие. На каждой стадии цель действий своя. Иногда происхо%
дит многократное повторение этих стадий в разном порядке, но каж%
дая команда проходит через все стадии. Более мелкие команды в со%
ставе основной команды разработки проекта проходят через аналогич%
ный процесс; это рекурсивная модель. Ниже мы рассмотрим детали,
относящиеся к каждой из этих стадий.
8. Резюме
Программистов по%настоящему заботит только то, как написать хоро%
ший код, поэтому имеет ли это все какое%то значение? Имеет: здоровье
и структура вашей команды оказывают прямое влияние на здоровье
и структуру вашего кода. Они неразрывно связаны. Программы пи%
шутся людьми. Хорошо согласовываться друг с другом, обмениваться
информацией и образовывать крепкую структуру должны не только
программные компоненты, но и программисты, пишущие их.
18 глава
Защита исходного кода
1. Наши обязанности
Будучи добросовестными ремесленниками, мы должны нести ответст%
венность за свою работу. Мы должны не только писать код высокого
качества, но и гарантировать для нашего продукта:
Надежную защиту
Недопустимо, чтобы код потерялся после трех месяцев работы над
ним или чтобы секретная информация, которую он собой представ%
ляет, вышла за пределы компании.
Доступность 
Те, кому полагается, могут легко модифицировать код. Его видят
только они и никто из посторонних.
Воспроизводимость
Выпущенный код не должен быть потерян или уничтожен. Должна
существовать возможность и через 10 лет собрать из него точно та%
кое же приложение, даже если версии инструментов поменялись
и язык программирования больше не поддерживается.
Сопровождаемость
Это означает не только использование хороших идиом программиро%
вания, но и возможность модификации кода всеми программистами
команды. Могут ли несколько программистов одновременно рабо%
тать над кодом или это приведет к катастрофе? Можно ли модифици%
ровать старые продукты, одновременно разрабатывая новую версию?
Эти цели достигаются путем применения техники безопасной разра%
ботки. В данной главе мы не рассматриваем вопросы безопасности ра%
ботающих приложений;1 нас интересует технология разработки. Мо%
жет показаться, что это скучные проблемы, мало связанные с процес%
сом написания кода, но не следует недооценивать их важность. Мас%
терство в такой же мере относится к творческому процессу, в какой к
его конечному результату.
2. Управление версиями исходного кода 
Для того чтобы члены команды могли совместно разрабатывать код,
они должны иметь возможность одновременно работать с базовым ко%
дом. Это не так просто, как может показаться – нужно сделать так,
чтобы не было конфликтов между одновременно осуществляемыми
модификациями кода и никакие результаты работы не потерялись.
3. Управление конфигурацией
Управление конфигурацией программного обеспечения – тема, близ%
кая к контролю за исходным кодом, но не следует одно путать с дру%
гим. Это отдельная большая тема. 
Как мы видели, перед системой контроля за исходным кодом стоят
следующие задачи: 
• Обеспечить централизованное хранение кода
• Сохранить историю изменений, которым подверглись файлы
• Дать возможность разработчикам совместно трудиться, не создавая
друг другу помех
• Дать возможность разработчикам решать задачи параллельно с по%
следующим слиянием результатов
4. Резервное копирование 
Это обычный здравый смысл. Резервные копии – ваша страховка про%
тив случайного удаления файла, отказа вычислительной системы и, ес%
ли копия хранится в другом месте, против потери данных в случае по%
жара в офисе. От простуды пока еще не лечат, но, возможно, какая%ни%
будь занимающаяся резервированием компания уже работает над этим.
5. Выпуск исходного кода
Иногда требуется ослабить хватку, с которой вы вцепились в свой ис%
ходный код, и отпустить его в Большой мир. Например, вы можете
продавать библиотеку, и вашим продуктом будет сам исходный код.
Может быть, в условиях контракта оговорено, что вместе с исполняе%
мым модулем вы должны предоставить исходный код. Даже если вы
не собираетесь выпускать свой исходный код, он может быть продан
новому владельцу или вы решите привлечь сторонних разработчиков
для реализации новой функции. Необходимо принять меры, чтобы
обеспечить защиту и доступность кода и в таких ситуациях.
6. Где я оставлю свой код…
Наконец, подумайте о месте для хранения своего исходного кода. Со%
вершенно секретную информацию компании не следует оставлять
в ноутбуке, лежащем в незапертой машине. Точно так же не стоит дер%
жать исходный код в общедоступной сети.
7. Резюме
В этой главе мы рассмотрели различные действенные методы, гаран%
тирующие, что мы берем на себя ответственность за создаваемый код
и разрабатываем его надежным и контролируемым образом. Это дей%
ствительно важные вещи; несчастье, если оно случится в опасный мо%
мент, может обернуться катастрофой для вашего проекта. Важный ба%
зовый код необходимо защитить.
19 глава
Спецификации
1. Что же это такое, конкретно? 
Спецификации – это официальные документы, участвующие в процес%
се разработки и предоставляющие внутреннюю документацию для
программного обеспечения. Есть много видов спецификаций (мы их
вскоре рассмотрим) для разного рода информации и разных аудито%
рий. Каждая спецификация относится к конкретной стадии процесса
создания программного обеспечения – от замысла проекта до итогово%
го поставляемого продукта. Мы пользуемся ими, чтобы точно зареги%
стрировать требования пользователя (или что он надеется получить,
если это разные – что, как правило, случается – вещи), подробно опи%
сать архитектуру программного решения, интерфейс конкретного мо%
дуля кода, решения о конструкции и реализации части кода и т. д.
2. Типы спецификаций
Спецификация каждого типа образует для программного продукта про%
межуточный шлюз – метод передачи данных между различными час%
тями процесса разработки. Например, спецификацию API программ%
ной компоненты пишет группа людей, которые рассматривают ее
функциональность и интерфейс. Программист действует согласно
этой спецификации; она достаточно полная, чтобы реализовать весь
код. Та же спецификация является контрактом, описывающим по%
дробности того, как системный интегратор может включить ее в систе%
му и как другие программисты могут ею пользоваться. Она описывает
также предположительное поведение компоненты, так что тестеры
могут проверить правильность ее работы.
3. Что должны содержать спецификации?
Разные типы спецификаций весьма различаются по содержанию. Од%
нако в любой спецификации в отношении информации должны соблю%
даться следующие требования: 
Корректность 
Несмотря на очевидность, это крайне важное требование. Некор%
ректная спецификация может стать причиной многих дней напрас%
ного труда. Необходимо ее постоянно обновлять, иначе она стано%
вится опасной: ее чтение оказывается потерянным временем, при%
водит к путанице и может стать причиной появления ошибок.
Если спецификация допускает неоднозначное толкование, это не
спецификация. Два человека, прочтя ее, сделают разные выводы,
что неизбежно приведет к печальным последствиям. Сделайте так,
чтобы ваши спецификации точно передавали ваш замысел.
В тексте не должно быть противоречий. Если спецификация оказы%
вается достаточно объемистой, соблюсти ее непротиворечивость ста%
новится затруднительно. Такая проблема особенно характерна для
случаев, когда модификацию проводит сопровождающий (не автор
кода) – легко, изменив информацию в одном месте, оставить в преж%
нем виде другие разделы, ссылающиеся на те же самые данные.
Спецификация должна быть составлена в соответствии с сущест%
вующими стандартами (например, определениями языка и приня%
тыми в фирме стандартами кодирования). Она должна следовать
принятым в фирме стандартам/соглашениям для документов и ис%
пользовать существующие шаблоны.
Понятность 
Хорошую спецификацию приятно читать и легко понимать. Она
понятна всякому, кто ее прочтет. Если она составлена настолько
техническим языком, что разобраться в ней могут только инжене%
ры, то прочие нетехнические службы (маркетинга или администра%
ции) сочтут, что этот документ написан не для них, и не отнесутся
к нему с должным вниманием. Возможные проблемы будут обнару%
жены слишком поздно.
Как и хороший код, лучшие спецификации пишутся с точки зре%
ния читателя, а не писателя. Информация представляется так, что%
бы быть понятной новичку, а не в удобном для автора виде. Блез
Паскаль как%то извинялся: «Это письмо получилось у меня слиш%
ком долгим, потому что у меня не было времени его укоротить».
Для хорошего стиля характерны краткость и очевидность главного
смысла, не затененного многословием. Для этого требуются лиш%
ние время и труд, но оно того стоит, если в результате достигается
простота изложения.
Не нужно думать, что спецификация должна содержать массу скуч%
ной прозы. Попробуйте применить приемы, сокращающие объем
и облегчающие чтение. Маркированные и нумерованные списки,
графики, заголовки и подзаголовки, таблицы и разумное использо%
вание пустого пространства позволяют разбить поток текста и по%
мочь читателю составить мысленную карту материала.
Полнота 
Спецификация должна быть самодостаточной и полной. Это не озна%
чает, что в ней должна содержаться вся мыслимая информация;
вполне допустимо ссылаться на относящиеся к делу документы, ес%
ли эти ссылки точны (учитывайте в них версии документов) и по%
зволяют читателю легко найти нужный документ. 
Уровень детализации в спецификациях не должен опускаться до де%
талей реализации, иначе она станет слишком ограничительной или
трудной для понимания. Люди склонны игнорировать сложные спе%
цификации, а потому они оказываются невостребованными. Остав%
шись пылиться в углу, они только вводят в заблуждение тех читате%
лей, которые не знают, что ими больше не руководствуются.
Проверяемость 
Спецификация интерфейса программной компоненты приводит к по%
явлению двух вещей: программной реализации и комплекта тестов
для ее проверки. Поэтому содержание спецификации должно под%
даваться проверке. На практике это сводится в основном к ее кор%
ректности, однозначности и полноте.
Модифицируемость 
Ничто не должно устанавливаться навечно – ни код, ни документы.
Если спецификация требует обновления (например, для исправле%
ния фактической ошибки), это не должно вызывать затруднений.
Жесткая спецификация помогает вам обрести почву под ногами.
Но если спецификация неверна, в этом нет никакого смысла. Доку%
мент должен быть доступен для редактирования (т. е. должен быть
обеспечен доступ к источнику, а не просто экземпляру в формате
PDF), а процедура выпуска и обновления не должна быть слишком
обременительной.
Чтобы облегчить модификации, документ должен быть тщательно
структурирован и иметь минимальный размер.
Самоописательность
В каждой спецификации должны присутствовать как минимум
следующие части: 
• Форзац, ясно показывающий название документа, подзаголо%
вок, авторов, номер версии, дату последней модификации и ста%
тус доступа (например, закрытый документ компании, распро%
странение на условиях NDA, открытый доступ). 
• Введение, содержащее краткие сведения о задачах, области при%
менения и предполагаемой аудитории.
• Термины и определения, необходимые для понимания содержи%
мого. (Но не относитесь к читателю свысока: если документ
предназначен инженерам%программистам, не нужно объяснять
им, что такое RAM.) 
• Ссылки на аналогичные или цитируемые документы.
• Исторический раздел, перечисляющий важные модификации
и версии.
Прослеживаемость 
Должна существовать процедура контроля за документами (типа
системы управления исходным кодом) и центральное файловое
хранилище документов. Каждая выпускаемая версия специфика%
ции должна помещаться в хранилище и оставаться доступной, что%
бы можно было узнать, с какой версией вы работали год назад;
в один прекрасный день она вам снова понадобится. Можно вос%
пользоваться системой управления версиями – этот инструмент го%
дится для отслеживания версий файлов любого типа.
На форзаце документа имеется контрольная информация (номер
версии, дата, автор и т. д.), которая позволяет убедиться, что у вас
на руках самый свежий экземпляр.
3. Процесс составления спецификаций
Теперь, когда мы знаем, какие типы спецификаций существуют и что
они должны содержать, мы полностью вооружены. Пора что%нибудь
написать! Процесс составления спецификации прост:
1. Выберите начальный шаблон документа. Он может быть определен
установленной процедурой разработки проекта. Если шаблона нет,
возьмите за основу существующую спецификацию.
2. Напишите документ. Действительно, это трудная часть. Что пи%
сать, зависит от типа спецификации.
3. Организуйте обсуждение документа. Привлеките всех, кому он мо%
жет быть интересен.
4. После согласования (и, если требует процедура, официального под%
писания) присвойте документу номер версии, поместите в хранили%
ще и разошлите соответствующим адресатам.
5. Если в дальнейшем возникнут проблемы, сделайте заявку на изме%
нение спецификации и проверьте, что вам ясно, как модификация
повлияет на объем работы по разработке. Если не ясно, то объем ра%
бот может совершенно незаметно удвоиться.
4. Почему мы не пишем спецификации?
Хорошие спецификации примечательны тем, что в реальности их не
найти. Мы знаем, что работать без них – нехорошо, поэтому шустрые
разработчики пытаются замять их отсутствие и сделать вид, что нет
никаких проблем. Довольно часто можно получить задание на про%
граммирование без надлежащих спецификаций требований или функ%
циональности. (Это методическая проблема, которую нужно решать
путем постоянных жалоб, просветительной работы, а при необходимо%
сти и превышения полномочий.)
5.Резюме
Конечно, составление спецификаций не самое приятное занятие в жиз%
ни разработчика программного обеспечения, но это важная часть про%
цедуры написания кода. Научитесь эффективно читать и писать их,
записывайте нужную информацию в нужном месте, чтобы избавить
себя в будущем от лишних затрат времени и неприятностей. Но не дай%
те поработить себя бумажной бюрократии.
20 глава
Рецензия на отстрел
1. Что такое «рецензирование кода»?
Рецензирование помещает код под микроскоп, имея задачей подверг%
нуть его критике и проверке. Его цель не высмеять автора, а повысить
качество программного обеспечения, создаваемого командой. Обычно
в его процессе создается список исправлений, которые нужно сделать
(его размер отражает уровень вашего мастерства!). Иногда отмечаются
усовершенствования, заниматься которыми в данный момент не стоит;
возьмите эти открытия на заметку, чтобы заняться ими в будущем.
2. Когда проводить рецензирование?
В идеале каждый кусочек кода должен быть тщательно прорецензи%
рован, прежде чем попасть в окончательную версию. Согласно Инсти%
туту технологии программирования Университета Карнеги%Меллона,
тщательное рецензирование кода должно занимать не менее полови%
ны всего времени кодирования (с учетом личного рецензирования). 
Это больше, чем может себе позволить большинство
реальных проектов.
2. Проведение рецензирования кода
Простого проведения рецензирования кода недостаточно. Само по себе
это не решает всех проблем.
3. Пересмотрите свое отношение
Рецензирование требует конструктивного подхода; без правильного от%
ношения пользы не будет. Это касается обеих сторон – и автора, и ре%
цензента.
4. Идеальный код
 Рецензируемый код должен быть: 
Свободен от ошибок
Ошибки – это наш враг и бич разработки хороших программ. Нам
нужна уверенность в качестве результатов своего труда, и ошибки
должны быть выявлены на возможно раннем этапе разработки.
Чем раньше мы станем их искать, тем раньше обнаружим и испра%
вим, и тем меньше убытков и неприятностей они нам причинят (см.
врезку «Экономика ошибок» на стр. 216).
Корректен 
Код должен отвечать всем действующим стандартам и требовани%
ям. Проверьте правильность типов всех переменных (например,
чтобы не возникло числового переполнения). Комментарии долж%
ны быть точными. Код должен соответствовать требованиям к па%
мяти и производительности (особенно важно для встроенных плат%
форм). Проверьте правильность параметров функций и обращений
к библиотекам.
Код должен быть проверен на соответствие спецификациям требова%
ний и функциональности. Считается, что спецификации были со%
ставлены корректно, если же нет – задача значительно осложняется!
Иногда комментарии в рецензии на код касаются спецификаций
(например, если они не вполне понятны), но это не входит в задачи
рецензирования – не отвлекайтесь на дискуссии относительно пра%
вильности спецификаций; секретарь должен зафиксировать про%
блему в протоколе, и рецензирование должно быть продолжено.
Полон 
Код должен полностью реализовывать функциональную специфика%
цию. Он должен быть удовлетворительным образом интегрирован и
отлажен и пройти все тесты. Комплект тестов должен быть полным.
Хорошо структурирован 
Убедитесь, что реализация разумно спроектирована, код легко по%
нять, дублирования и избыточности в коде нет. Проверьте, напри%
мер, что нет бросающихся в глаза образцов программирования пу#
тем копирования и вставки.
Предсказуем
В коде не должно быть чрезмерной сложности и неожиданных сюр%
призов. Код не должен модифицировать себя сам, не должен основы%
ваться на неопределенных начальных значениях и не должен вызы%
вать подозрений в возможности бесконечных циклов или рекурсий.
Надежен
Код придерживается защитной стратегии. По возможности обеспе%
чена защита против обнаруживаемых ошибок времени выполнения
(деления на нуль, недопустимых численных значений и т. п.). Все
данные ввода должны проверяться (как параметры функций, так и
вход программы). Код обрабатывает все возникающие ошибки и ис%
ключения. Все необходимые сигналы перехватываются.
Контролирует ошибки
При доступе к массивам в стиле С осуществляется проверка границ.
Отсутствуют другие аналогичные коварные ошибки доступа к дан%
ным. Если в коде несколько потоков, для предотвращения состоя%
ния гонки и взаимной блокировки правильно используются мью%
тексы. Проверяются все значения, возвращаемые системными/биб%
лиотечными вызовами.
Легок в сопровождении
Программист разумно применяет комментарии. Код хранится в сис%
теме управления версиями. Имеются необходимые данные о конфи%
гурации. Форматирование кода отвечает внутрифирменным стан%
дартам. Код успешно компилируется без вывода многочисленных
предупредительных сообщений.
5. За пределами рецензирования кода
Процесс рецензирования – важный элемент выпуска любого продукта
высокого качества, поэтому его применение не ограничивается разра%
боткой исходного кода. Аналогичная процедура рецензирования при%
меняется при создании спецификаций, перечней требований и т. п.
6. Резюме
Рецензирование кода – важная часть процедуры разработки программ%
ного обеспечения, которая помогает обеспечить высокое качество кода.
Подобно тому как подмастерье осваивает ремесло благодаря передаваемым 
ему секретам, так и рецензирование кода способствует распро%
странению знаний и обучению кодированию. Будучи в большей мере
взаимодействием между равными, чем между учеником и мастером,
рецензирование позволяет учиться как автору, так и рецензенту.
Пишите код в расчете на рецензирование. Помните, что читать его бу%
дете не только вы сами; другие люди должны иметь возможность его
сопровождать. Автор всегда отвечает за качество своей работы. Хоро%
ший программист более заботится о создании отличного кода, чем об
удовлетворении своего чувства гордости.
21 глава
Какой длины веревочка?
1. Выстрел в темноте
В любой организации, в любом проекте и в любой момент оценки сро%
ков разработки программного обеспечения представляют собой лишь
основанные на фактах догадки – иначе они и не были бы оценками. Га%
дание, конечно, вызывает сомнение в профессионализме, но ничего
лучшего не существует: вы никогда не узнаете точно, сколько времени
требует задача, пока она не будет завершена, а к тому моменту эта ин%
формация обычно оказывается бесполезной.
2. Почему трудно делать оценки?
Я живу в Кембридже, в Соединенном Королевстве; моя семья живет
в Бристоле. Оценка времени разработки похожа на оценку времени, ко%
торое мне нужно, чтобы навестить своих родственников. Легко опреде%
лить длительность поездки при попутном ветре и отсутствии пробок. Но
если на дороге ведутся работы, или есть пробки, или сломается машина,
или я поздно выеду, или я поеду в часы пик, оценка становится менее
надежной. Если я предвижу какие%то проблемы, то могу назвать вероят%
ный интервал времени своего прибытия. Я знаю, сколько займет поезд%
ка в самых благоприятных обстоятельствах; у меня есть представление
о худшем сценарии (иногда мои поездки бывают ужасны). Я могу оце%
нить время прибытия как промежуточное между двумя крайними мо%
ментами. Однако я никогда не могу предвидеть все случаи – если сло%
мается машина, я застряну. Мобильный телефон в такой ситуации по%
лезен: если я опаздываю, можно позвонить домой и предупредить, что%
бы там подогрели для меня ужин (и не отдавали его собаке).
3. Под давлением
Там, где занимаются промышленным производством программ, не
размышляют и испытывают большой соблазн делать оптимистические
оценки. Особенно уязвимы программисты, впервые участвующие в этой
игре. Руководство требует от них сжатых графиков, объясняя, как это
важно для получения новых контрактов, объявления о новых рели%
зах, поддержания внутренней политической стабильности и т. п. Это
все понятная и объяснимая реальность; ни одна компания не живет
в вакууме, и держатели акций желают есть икру и пить шампанское.
4. Практические способы оценки
Как нам справиться с нарастающим давлением на нас с целью превра%
тить программистов в пророков? Точность оценки, как и многие дру%
гие навыки, приходит с опытом. Не нужно ждать старости, но если не
работать в условиях риска срыва графика и не ставить себе целей,
к которым нужно стремиться, то вы не улучшите свое мастерство в этом
деле. Совершенство достигается путем тренировки.
5. Игры с планами 
Несколько не связанных между собой оценок времени никому не инте%
ресны. Их нужно объединить, создав нечто полезное: план проекта,
с помощью которого можно управлять графиком разработки. В соот%
ветствии со своими отдельными оценками времени задачи размещают%
ся на графике работ и распределяются между разработчиками. Выяв%
ляются зависимости между задачами и учитываются в плане (очевид%
но, что зависимые задачи нельзя начать ранее, чем будут завершены
те, от которых они зависят).
6. Не отставай!
Когда работа отстает от графика и приближается срок сдачи продукта,
программисты работают очень напряженно, но им не доверяют. О не%
обходимости строгого тестирования напрочь забывают в безумном
стремлении сдать что%то готовое в срок. Основной причиной этого цир%
ка являются неверные оценки. Они способствуют созданию у менедже%
ров неправильных представлений о сложности задач разработки – от%
куда им было знать, что график составлен некорректно? Когда мы да%
ем оценку срока, мы не должны ошибиться.
7. Резюме
Оценка времени работы и планирование помогают нам выпускать ком%
мерчески успешное программное обеспечение. Однако не существует
точных методов оценки продолжительности разработки. Поэтому при%
ходится довольствоваться оценками.
Стремитесь совершенствовать свои методы оценивания и следите за
потенциальными проблемами, которые могут сорвать ваш тщательно
разработанный план разработки. Научитесь работать согласно графи%
ку и определять, когда ваши графики нереальны.
22 глава 
Рецепт программы
1.Стили программирования
Стиль программирования описывает, как планируется решение зада%
чи, как оно делится на части и моделируется на выбранном языке. Мы
должны создавать модели решений, потому что полезная система не
может целиком уместиться в голове разработчика. Стиль программи%
рования определяет, каким образом мы разбиваем проект на управ%
ляемые части; это парадигма проектирования, служащая выражению
задач вашего кода.
2. Рецепты: как и что
Мы изучим два разных аспекта. В «рецептах» программирования уча%
ствуют как процедура разработки, так и стиль программирования.
Это разные, но взаимосвязанные вещи:
• Процесс разработки представляет собой крупный план: он описыва%
ет шаги, которые нужно сделать для создания программного про%
дукта. Он охватывает всю организацию, где ведется разработка, а не
только программистов. Как правило, создание программ – работа,
в которой участвует много людей; процесс показывает, как органи%
зовать массу людей, чтобы они создали какое%то согласованное це%
лое. По крайней мере, он должен попытаться это сделать.
• Стиль программирования представляет собой мелкий план: это ле%
жащий ниже способ расчленения, создания и склеивания компо%
нент. Скорее всего, на него окажет влияние выбор процесса разра%
ботки, хотя это необязательно.1 Более вероятно, что влияние ока%
жут целевой язык и предшествующий опыт разработчика.
Оба эти аспекта разработки могут называть методологиями, из%за чего
их легко спутать.2 Мы уже рассмотрели стили программирования, а да%
лее обсудим процессы разработки. Важно овладеть разными имеющи%
мися методами разработки, чтобы расширить свой кругозор и пра%
вильно выбрать процесс, если вам представится возможность выбора.
3. Процессы разработки
Существует много процессов разработки, поскольку есть люди, кото%
рые любят их изобретать. Многие из них лишь незначительно развива%
ют одну%две базовые модели. Эти базовые варианты мы здесь рассмот%
рим. Как вы убедитесь, некоторые из них тесно связаны между собой.
Выбор вами процесса разработки определяет планирование проектов,
переход работы из одной фазы в другую и взаимодействие между чле%
нами команды, осуществляющей проект. Различие между процессами
проявляется по разным направлениям:
Толстый/тонкий
Толстый процесс разработки тяжел и бюрократичен. Он создает
массу бумажных документов, регламентирует поведение разработ%
чиков и предполагает определенную структуру команды. Его ха%
рактеризует организационная модель ISO 9000, в которой каждая
производственная процедура раболепно расписана во всех деталях,
несмотря на изъяны или неуместность процесса.
На другом полюсе располагаются тонкие процессы разработки, из%
бегающие ненужной бюрократичности и благоприятствующие бо%
лее скромным и ориентированным на людей принципам. Такую
практику поддерживают процессы ускоренного программирования,
описанные на стр. 547.
Последовательность событий 
В некоторых процессах разработки разумно учитывается, что ре%
альность непредсказуема, и предпринимаются попытки учесть это
в планах путем выполнения нескольких итераций в цикле процес%
са. Это дает возможность разработчикам учесть в новой итерации
результаты, полученные на предыдущей. Они могут приспособить%
ся к естественным изменениям, происходящим по мере разработки
продукта (новые требования клиентов, непредвиденные проблемы
и т. п.).
Другие процессы более регламентированы и линейны и полагаются
на формальный переход разработки от одной стадии к другой. Они
предусматривают значительные затраты на предварительное пла%
нирование и попытки в деталях предвидеть будущее. Такие пред%
сказания ограничивают возможность будущих коррекций направ%
ления разработки.
Направление проектирования
При нисходящем проектировании система создается на основе на%
чального общего представления. Каждый пакет верхнего уровня
уточняется и подвергается разбиению на составляющие. Этот про%
цесс продолжается до тех пор, пока не будут получены специфика%
ции продукта, позволяющие начать работу. В нисходящем проек%
тировании велика роль планирования и хорошего представления
о результирующей системе и предполагается, что в процессе разра%
ботки требования будут меняться мало.
В противоположной процедуре – восходящем проектировании –
подробно описываются отдельные части системы, а затем отыски%
вается лучший способ соединить их вместе. При этом легче вклю%
чить в новый проект уже существующие компоненты. В современ%
ной практике эти два подхода часто объединяются – для начально%
го планирования создается некоторое представление о системе в це%
лом, а затем происходит выявление и кодирование компонент
и объектов низкого уровня.
4. Спасибо, хватит!
Если вы добрались до этого места и вам не наскучило читать, это хоро%
шо. В конце концов, самое главное – какие выводы нужно сделать из
всего этого? Программист%мастер должен на практике хорошо разби%
раться в процессах разработки и стилях программирования, но эти зна%
ния любой может почерпнуть из соответствующих книг. Как с пользой
применить их в работе? Как они могут повысить наше мастерство?
5. Выбор процесса
Есть много факторов, влияющих на правильный выбор процесса раз%
работки. Однако выбор редко исходит из разумных оснований; про%
цесс выбирают, потому что мы всегда так работали, он достаточно
хорошо работает или это первое, что пришло нам в голову.
6.Резюме
Создание программного продукта сродни преступлению: оно удается,
когда хорошо организовано. Случается, что команда без всякой дисцип%
лины выдает нечто примечательное и создает программный шедевр.
Но это исключение. Чтобы процесс разработки был эффективным, он
должен быть определен, а также понят и поддержан членами коман%
ды, обладающими достаточной квалификацией. Иначе полученный
программный продукт окажется безобразным.
23 глава
За гранью возможного
1. Программирование приложений
Это то, что представляет себе большинство гуманитариев, когда вы
произносите слово программирование.1 По%видимому, это самая круп%
ная из рассматриваемых в данной главе категорий.
Имеется в виду программирование приложений – законченных про%
грамм – как правило, для однопользовательских компьютеров типа ра%
бочей станции. В этой области в центре внимания находятся пользова%
тели и их работа с настольными системами. В силу коммерческих при%
чин целевыми платформами обычно являются самые распространен%
ные – в настоящее время Windows и Mac OS. Хотя сейчас много говорят
о программировании для Linux, это все еще не та область, в которой со%
средоточена работа над приложениями (по крайней мере, в данное вре%
мя). По мере того как портативные устройства становятся все более
мощными, а среды разработки приложений для них все богаче, разра%
ботка мобильных приложений переместилась из области встроенных
приложений (см. раздел «Встроенное программное обеспечение» на
стр. 563) в данный класс программирования приложений более обще%
го назначения. Особые препятствия на пути разработки встроенных
приложений в значительной мере устранены.
2. Программирование игр
Захватывающий и чарующий мир программирования игр – это специ%
фическая форма разработки приложений, обычно в коробочном виде.
В значительной мере борьба ведется с помощью подкупающего марке%
тинга и очень удачной идеи игры. Это тонкая граница между выдаю%
щимися, успешными играми и теми, которые не вышли в призеры.
3. Системное программирование
Приложения работают поверх богатых системных библиотек: различ%
ных уровней кода, обеспечивающих сетевое взаимодействие, графиче%
ские интерфейсы, многозадачность, доступ к файлам, мультимедийные
возможности, управление периферийными устройствами, связь между
процессами и т. д. Если прикладные программисты получают сущест%
венную поддержку от системы, то кто%то должен снабдить систему этими
средствами поддержки. В этом и состоит системное программирование.
4. Встроенное программное обеспечение
Компьютерные технологии появляются во всех областях нашей жиз%
ни, даже если мы этого не замечаем. Мы постоянно пользуемся разны%
ми устройствами и приспособлениями, от микроволновых печей до ча%
сов, от радиоприемников до термостатов. Эти электронные приборы
бытовой техники требуют для своего функционирования программно%
го обеспечения. Как правило, пользователь устройства не видит его
управляющей программы. Встроенное программное обеспечение есть
не только в бытовой технике: программами управляются все устройст%
ва с микроконтроллерами, например лабораторные приборы или ма%
шинки, выдающие квитанции на парковке. Мы должны написать про%
граммы, встраиваемые в аппаратные устройства: встроенное про%
граммное обеспечение.
5. Программирование распределенных систем
Распределенные системы состоят из нескольких компьютеров. Как мы
увидим позднее, Всемирная паутина фактически представляет собой
огромную распределенную систему, в которой информация хранится
на многочисленных компьютерах, разбросанных по разным континен%
там, а приложения удаленно загружаются с помощью веб%броузера.
Хотя дело не ограничивается броузерами. Архитектуры из нескольких
машин используются во многих ситуациях. Проектирование и созда%
ние распределенных систем выдвигает целый ряд новых проблем.
6. Программирование вебNприложений
В 1990 году Тим Бернерс%Ли создал первые броузер и сервер HTML,
и родилась World Wide Web. Сегодня это вездесущая технология,
и серверы могут предоставлять не только статические страницы с ин%
формацией, но и динамически создавать страницы с помощью про%
грамм, выполняемых на веб%сервере. Это весьма специфическая форма
распределенных вычислений, в которой интерфейс пользователя – веб%
броузер – находится у удаленного клиента. 
Примерами такого рода приложений служат:
• Электронная торговля
• Доски объявлений, службы передачи сообщений и почтовые систе%
мы, базирующиеся на веб 
• Системы заказа билетов
• Механизмы поиска в Интернете
7. Программирование масштаба предприятия
Предприятие (enterprise) – это скучное, постоянно звучащее слово,
скорее из новояза менеджеров, чем из лексикона программистов. Бук%
вально оно означает бизнес%организацию. Так что программирование
масштаба предприятия (enterprise programming) создает системы для
целых компаний, объединяя их отдельные системы в одно тесно свя%
занное целое. Почти всегда программирование масштаба предприятия
подразумевает разработку крупных распределенных систем.
8. Численное программирование
Численное программирование предполагает решение научных, весьма
специальных технических задач с активным использованием матема%
тических методов. Это очень специализированная область, где пишутся
приложения, особо ориентированные на решение конкретных число%
вых задач. Часто программы рассчитаны на суперкомпьютеры – очень
быстрые машины, способные проводить сложные расчеты. Это очень
дорогие платформы, применяемые для специальных приложений,
в которых требуются огромные объемы математических вычислений.
9. И что дальше?
Какое значение имеют для нас эти ниши программирования? Как
должны мы действовать, зная о них? Чтобы стать хорошим програм%
мистом, настоящим мастером, нужно знать:
• В какой области вы работаете – какого рода программы делаете.
• Какое влияние оказывает эта область на архитектуру. (Это много%
уровневая система предприятия или крепко скрученный встроен%
ный код? См. главу 14.)
• Какие конструкции кода подходят и не подходят в данной области.
(Например, требуется ли жертвовать ясностью и изяществом в поль%
зу эффективности, предельно сжимать исполняемый образ или ос%
тавлять много ловушек для последующих расширений?)
• Какими инструментами пользоваться – что доступно, а что нет.
• Какой язык программирования лучше выбрать и какие идиомы ко%
дирования применять.
10. Резюме
Мы лишь обмакнули палец и попробовали на вкус разные виды про%
граммирования. Разумеется, есть и другие, которых мы не коснулись:
одни более четко очерченные, другие менее. Например, программное
обеспечение, критичное с точки зрения безопасности, управляет сис%
темами, требующими высокой надежности, такими как медицинское
или авиационное оборудование. Здесь отказы недопустимы, и коррект%
ность кода должна быть проверяема. Это оказывает существенное вли%
яние на способы проектирования и написания такого ПО.
24 глава
Что дальше?
1. Но что же дальше?
Вы никогда не достигнете совершенства в искусстве программирова%
ния; лучшее, что вам доступно, – это состояние постоянного развития.
Всегда найдется то, чего вы еще не знаете. Так что же делать дальше?
Тот факт, что вы об этом спрашиваете, уже многое значит: одна из
главнейших характеристик программиста%мастера – желание совер%
шенствоваться.
